# SVN核心知识与Git对比笔记

# 一、SVN基础核心

## 1.1 定义与核心定位

Subversion（SVN）是开源的**集中式版本控制系统**，依赖唯一中央仓库管理全量版本历史，适用于中小型团队集中式协作，核心价值是实现多人协作开发中的文件版本追踪与同步。

## 1.2 核心概念（与Git对应对照）

|SVN概念|解释|Git对应概念|
|---|---|---|
|中央仓库（Repository）|唯一权威数据源，存储完整版本历史（文件、分支、标签、属性等）|远程仓库（remote）|
|工作副本（Working Copy）|本地检出的项目快照，含隐藏`.svn`目录存储元数据（仓库URL、基准版本等）|工作区+本地仓库（简化版）|
|检出（Checkout）|从中央仓库获取当前版本文件+元数据到本地|git clone|
|提交（Commit）|直接将本地修改同步到中央仓库，生成新修订号，立即生效|git commit + git push（Git commit仅到本地仓库）|
|更新（Update）|从中央仓库获取最新修改同步到本地工作副本|git pull（=git fetch + git merge）|
|svn add|标记新文件为版本控制对象，需commit生效|git add（添加到暂存区）|
## 1.3 基础工作流

拷贝-修改-合并（Copy-Modify-Merge）：
1. 检出（Checkout）工作副本 → 2. 本地修改 → 3. 更新（Update）同步最新版本并解决冲突 → 4. 提交（Commit）到中央仓库

## 1.4 安装核心要点

- Windows：客户端（SlikSVN命令行/TortoiseSVN图形化）、服务器（VisualSVN Server，需配置仓库路径、权限）

- macOS/Linux：通过包管理器（brew/apt/yum）安装subversion，服务器可通过`svnadmin create`创建仓库

# 二、SVN工作原理

## 2.1 核心架构：集中式模型

仅两个核心角色：
- 中央仓库：服务器端，唯一存储完整版本历史，负责权限校验、冲突检测、版本管理；
- 工作副本：客户端，仅存储当前版本文件+元数据，无完整历史，大部分操作需联网依赖中央仓库。

## 2.2 数据存储：增量存储+全局修订号

- 增量存储（Delta-Based）：仅记录当前版本与上一版本的差异（首次提交存储完整基线），节省服务器存储空间；

- 全局修订号（Revision）：每次提交生成唯一递增数字（如r1、r2），标记项目整体状态，由中央仓库统一分配；

- 存储引擎：默认FSFS，核心存储区为仓库`db`目录（`revs/`存变更数据、`transactions/`存未完成提交）。

## 2.3 关键流程底层逻辑

### （1）检出（Checkout）

客户端请求 → 服务器返回最新版本文件+元数据 → 本地创建工作副本+`.svn`目录 → 标记基准版本=最新修订号。

### （2）更新（Update）

客户端发送本地基准版本 → 服务器计算与最新版本的差异 → 客户端合并差异（无冲突则更新基准版本，有冲突则标记并生成临时文件）。

### （3）提交（Commit）

本地校验（版本是否最新、文件状态是否合法） → 服务器验证权限与冲突 → 原子性提交（全成功/全失败） → 生成新修订号 → 客户端更新基准版本。

### （4）冲突处理

检测时机：更新阶段；
冲突标记：生成3个临时文件（`.mine`本地版本、`.rOLD`基准版本、`.rNEW`仓库最新版本）；
解决流程：编辑文件→`svn resolved`标记解决→提交。

## 2.4 分支与标签

本质是「目录拷贝」（硬链接拷贝，不复制文件内容），存储在中央仓库的`branches/`（分支）、`tags/`（标签）目录；合并时需对比两个目录的逐版本差异，效率较低。

# 三、SVN propset属性详解

## 3.1 核心作用与范围

propset用于给文件/目录添加元数据（如`svn:ignore`忽略规则），**既不全局生效，也不局限于当前Shell**：
- 未提交：仅本地工作副本的目标对象生效；
- 提交后：绑定到版本库的目标对象，所有开发者更新后均生效。

## 3.2 关键操作

- 设置：`svn propset svn:ignore "*.log" .`（当前目录忽略.log文件），`-R`参数可递归作用于子目录；

- 查看：`svn propget svn:ignore .`；

- 删除：`svn propdel svn:ignore .`；

- 注意：属性修改需commit后才对团队生效。

## 3.3 与Git配置的区别

|特性|SVN propset|Git配置|
|---|---|---|
|作用对象|版本库中的文件/目录|仓库级/全局级（如.gitignore、~/.gitconfig）|
|存储位置|版本库（提交后）+ 本地工作副本（未提交）|本地配置文件（.git/config、~/.gitconfig）|
|团队共享|提交后自动共享|.gitignore需手动提交共享，全局配置不共享|
# 四、SVN与Git核心差异

## 4.1 核心维度对比

|对比维度|SVN（集中式）|Git（分布式）|
|---|---|---|
|架构核心|中央仓库唯一存储完整历史|每个本地仓库存储完整历史|
|存储模型|增量存储（记录版本差异）|快照存储（记录每次完整快照，未改文件复用引用）|
|版本标识|全局递增修订号（r1、r2），中央生成|基于内容的哈希ID（SHA-1），本地生成|
|本地能力|弱，大部分操作需联网|强，离线可完成提交、分支、合并等所有操作|
|分支实现|目录拷贝，效率低|轻量级指针，创建/切换/合并瞬时完成|
|冲突检测|更新阶段（同步服务器时）|合并/拉取阶段（本地操作时）|
|冲突标记|生成3个临时文件|文件内插入冲突标记（<<<<<<<等）|
|解决后标记|需执行svn resolved|git add即可，无需额外标记|
## 4.2 存储模型核心差异

- SVN增量存储：依赖版本链，还原旧版本需从基线叠加所有差异，历史访问需联网；

- Git快照存储：本地有完整快照，历史访问离线瞬时完成，通过复用+压缩优化存储，无大量冗余。

# 五、Git冲突处理（补充核心流程）

## 5.1 冲突触发场景

合并分支（git merge）、拉取远程代码（git pull）、变基（git rebase）时，同一文件同一部分被不同修改。

## 5.2 冲突表现

- 命令行提示：Auto-merging failed，提示冲突文件；

- 文件标记：插入<<<<<<< HEAD（当前分支）、=======（分割线）、>>>>>>> 分支名（待合并分支）；

- 状态标识：git status显示冲突文件为both modified。

## 5.3 解决核心流程

1. 编辑冲突文件：删除冲突标记，保留需要的修改；

2. 标记解决：git add 冲突文件；

3. 提交结果：git commit（自动生成合并提交信息）。

## 5.4 进阶技巧

- 可视化工具：VS Code/PyCharm内置对比界面，支持快速选择保留修改；

- 放弃操作：git merge --abort（合并）/ git rebase --abort（变基）；

- 预防冲突：小步提交、频繁同步、明确分工、忽略无关文件。

# 六、核心总结

- SVN核心：集中式架构，依赖中央仓库，增量存储+全局修订号，操作需联网，分支合并效率低，适合中小型集中协作；

- Git核心：分布式架构，本地完整仓库，快照存储+哈希标识，离线能力强，分支灵活高效，适合分布式协作；

- Git用户适配SVN关键：理解commit直接提交中央仓库、更新阶段处理冲突、无本地提交缓冲的核心差异，养成“先update→修改→测试→commit”的习惯。
> （注：文档部分内容可能由 AI 生成）