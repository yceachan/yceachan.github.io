# 虚拟字符设备

![image-20250801093157931](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508010931027.png)

## fops file_operation

![image-20250801080748766](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508010807955.png)

```
// 文件操作结构体
static const struct file_operations vchar_fops = {
    .owner = THIS_MODULE,
    .open = vchar_open,
    .release = vchar_release,
    .read = vchar_read,
    .write = vchar_write,
};
```

## 设备号 alloc_chrdev_region

Linux 提供了一个**名为 dev_t 的数据类型**表示设备号其中高 12 位为主设备号(MAJOR)， 低 20 位为次设备(MINOR)。

这是一个LINUX内核中的二级链表，一般地，MAJOR用于区分设备种类，MINOR用于标识该类型中本设备的序号

以下是三个在驱动开发中好用的宏：

```c
MAJOR() // 用于从 dev_t 中获取主设备号，将 dev_t 右移 20 位即可。
MINOR() //用于从 dev_t 中获取次设备号，取 dev_t 的低 20 位的值即可。
MKDEV() //用于将给定的主设备号和次设备号的值组合成 dev_t 类型的设备号。
```

```c
dev_t dev_num = 0;
/*参数：
* 1 ：dev_t 指针，
* 2 : 起始，major 号 ，0为默认分配
* 3 : count 需要连续分配minor的设备号数量
* 4 ：设备名称
* 返回 ：返回0或错误码
*/
result = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (result < 0) {
        pr_err("Failed to allocate char device region\n");
        return result;
    }
    major_num = MAJOR(dev_num);

```

## struct cdev

在`<linux/cdev.h>`中定义，主要包含以下成员：

```c

struct cdev {

   struct kobject kobj;          // 内嵌的内核对象，用于引用计数等

   struct module *owner;         // 指向拥有该结构的模块的指针（通常为THIS_MODULE）

   const struct file_operations *ops; // 文件操作函数集

   struct list_head list;        // 用于将cdev加入系统的链表

   dev_t dev;                    // 设备号（主设备号和次设备号）

  unsigned int count;           // 关联的次设备号数量

};
```

* api

```c
static struct cdev vchar_cdev;

cdev_init(&vchar_cdev, &vchar_fops);
//*参数 ： 1.设备指针 2.起始设备号 3.设备数量
result = cdev_add(&vchar_cdev, dev_num, 1);
```

## class create

`class_create` 和 `device_create` 是 Linux 设备驱动模型中的关键函数，用于自动创建设备节点（通常在 `/dev` 目录下）。它们属于 Linux 统一设备模型的一部分，**与 sysfs 紧密相关。**

```
static struct class *vchar_class = NULL;
my_class = class_create(THIS_MODULE, "myclass"); //返回一个类对象给指针。
```

1. **`class_create`**:
   - 创建设备逻辑类别
   - 在 `/sys/class` 下建立类目录
   - 为设备提供统一管理接口

## device_create

```c
static struct device *vchar_device = NULL;
/*
* 1.class类模型
* 2.parent 设备指针（用于构建设备树层次结构）NULL
* 3.devt    设备号
* 4.prvdate 私有数据指针 NULL
* 5.设备名字
*/
dev_ptr = device_create(my_class, NULL, dev, NULL, "mydevice");
```

## 总结 module_init

Linux内核提供的**MACRO magic**，用于提供驱动模块在加载时的**init hook**，编程者需要实现初始化方法

流程如下：

* alloc_chrdev_region 分配设备号
* cdev_init、cdev_add 注册设备对象  （锁定设备号，关联cdev 与 fops接口）
* class_create,module_init 注册设备类，生成统一设备文件模型，创建设备节点

## 附录 printk

**printk在内核中用来记录日志信息的函数**，只能在内核源码范围内使用。和printf非常相似。
printk函数主要做两件事情：**①将信息记录到log中 ②调用控制台驱动来将信息输出** （一般是串口）

如果使用 printk 的时候不显式的设置消息级别，那 么printk 将会采用**默认级别MESSAGE_LOGLEVEL_DEFAULT，默认为 4**。

```shell
#define KERN_SOH  "\001" 
#define KERN_EMERG KERN_SOH "0"  /* 紧急事件，一般是内核崩溃 */
#define KERN_ALERT KERN_SOH "1"  /* 必须立即采取行动 */
#define KERN_CRIT  KERN_SOH "2"  /* 临界条件，比如严重的软件或硬件错误*/
#define KERN_ERR  KERN_SOH "3"  /* 错误状态，一般设备驱动程序中使用KERN_ERR 报告硬件错误 */
#define KERN_WARNING KERN_SOH "4"  /* 警告信息，不会对系统造成严重影响 */
#define KERN_NOTICE  KERN_SOH "5"  /* 有必要进行提示的一些信息 */
#define KERN_INFO  KERN_SOH "6"  /* 提示性的信息 */
#define KERN_DEBUG KERN_SOH "7"  /* 调试信息 */
printk(KERN_DEBUG"gsmi: Log Shutdown Reason\n");
```



# 编译、使用

## 附录 ：驱动makefile模板

### make -c

 -c可以切换make的工作目录，当make切到一个母目录有makefile的子目录时，**会递归地加载顶层Makefile**，这使得这份母目录外地makefile有依赖内核源码makefile地机会

### obj-m := xxx.o

- **obj-m**: 内核makefile的变量，用于链接用户的驱动代码
  - 指定要编译为可加载内核模块的目标
  - 扩展名为 `.o`，但实际生成 `.ko` 文件

**多文件模块**：如果模块由多个源文件组成（比如`file1.c`, `file2.c`），则需要使用一个特殊的语法：

  ``` makefile

 obj-m := mymodule.o

 mymodule-objs := file1.o file2.o  //同名.c文件将被编译

  ```
模板
```makefile
obj-m := virtual_char.o
KERN_DIR = <parh>

all:   //M 是内核Makefile中定义的特殊变量
     make -C $(KERN_DIR) M=$(PWD) modules

clean:
     make -C $(KERN_DIR) M=$(PWD) clean
```

![image-20250729021609722](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202507290216790.png)

## 内核模块.ko

- 内核模块是Linux内核向外部提供的一个插口
- 内核模块是具有独立功能的程序，他可以被单独编译，但不能单独运行。他在运行时被链接到内核作为内核的一部分在内核空间运行
- 内核模块便于驱动、文件系统等的二次开发

1. 加载模块

   * insmod XXX.ko
     为模块分配内核内存、将模块代码和数据装入内存、通过内核符号表解析模块中的内核引用、调用模块初始化函数（module_init）**insmod无法处理模块依赖关系**
   * modprobe XXX.ko
     加载模块时会同时加载该模块所依赖的其他模块，提供了模块的依赖性分析、错误检查、错误报告
   * **rmmod XXX.ko**
   * lsmod
   * modinfo XXX.ko :查看.ko动态库的信息

   ![image-20250801081821855](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508010818910.png)

## insmod mknod 与device_create

* 区别对比

![image-20250801092042504](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508010920640.png)

* 联系

![image-20250801092116009](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508010921095.png)

![image-20250801092246980](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508010922067.png)

# 同时申请多个同类型字符设备-Practice

```c
#include "linux/cdev.h"
#include "linux/export.h"
#include "linux/fs.h"
#include "linux/kdev_t.h"
#include "linux/kern_levels.h"
#include "userkey.h"
#include "linux/input-event-codes.h"
#include <linux/device.h>
#include <linux/module.h>
#include <linux/init.h>
#define KEY_SIZE 2

//静态声明dev成员。
struct key_dev key_dev [KEY_SIZE] ;

struct key_desc keyd [KEY_SIZE] = {
    {
        .name = "key0",
        .gpio = 129,
        .dev  = & key_dev[0]
    },
    {
        .name = "key1",
        .gpio = 110,
        .dev  =  & key_dev[1]
    }
};

int key_open (struct inode * inode, struct file *file){
    return 0;
}
int key_release (struct inode * inode, struct file *file){
    return 0;
}
long key_ioctl (struct file *file, unsigned int cmd , unsigned long flag){
     return 0;
}

struct file_operations fops ={
    .owner = THIS_MODULE,
    .open = key_open,
    .unlocked_ioctl = key_ioctl,
    .release = key_release
};


static int __init userkeys_init (void) {
    
    //*先request这个类型的dev_num，create class，
    int ret =alloc_chrdev_region(& (keyd[0].dev->cdev.dev), 0, KEY_SIZE, "userkeys");
    if (ret) {
        printk(KERN_ERR"alloc error");
        return ret;
    }
    struct class * class = class_create(THIS_MODULE, "userkeys");
    int major = MAJOR (keyd[0].dev->cdev.dev) ;
    
    //*再分别向内核注册每个cdev object 和dev_node file
    int i;
    for ( i = 0; i < KEY_SIZE; i++)
    {
        printk("before cdev_init");
        struct key_dev *pdev = keyd[i].dev;

        pdev->class =class;
        pdev->dev_num = MKDEV(major , i);
        pdev->cdev.owner = THIS_MODULE;

        cdev_init(& pdev->cdev, &fops);
       
        ret = cdev_add(& pdev->cdev, pdev->dev_num , 1);
            if (ret) { printk(KERN_ERR"cdev_add error");return ret;}

        device_create ( class ,NULL , pdev->dev_num , NULL , "%s%d","key",i);
    }   

    return 0;
}

static void __exit userkeys_exit (void) {
    int i;
    for (i = 0; i < KEY_SIZE; i++) {
        
        struct key_dev *pdev = keyd[i].dev;
        device_destroy(pdev->class, pdev->dev_num);
        cdev_del(&pdev->cdev);
    }
   class_destroy(keyd[0].dev->class);
   unregister_chrdev(MAJOR(keyd[0].dev->dev_num), "userkeys");
}


module_init(userkeys_init);
module_exit(userkeys_exit);
MODULE_VERSION("1.0");
MODULE_LICENSE("GPL");
MODULE_AUTHOR("yceahcan");
MODULE_DESCRIPTION("My Driver for user bottons");
```

## fops-通过接口file参数访问设备

> 1.使用iminor(inode) 在open函数里获得次设备号，**以此找到硬编码的minor 对应的index。**
>
> 2. file->private_Data 来绑定设备指针，实现在READ/WRITE函数时，通过file指针来获取设备指针

```c

int key_open (struct inode * inode, struct file *file){
    int minor = iminor(inode);
    // struct key_desc *keyd = file_to_keyd(file);
    switch (minor) {
	default:
	case 0:
		file->private_data = &keyd[0];
		break;
	case 1:
		file->private_data = &keyd[1];
		break;
	}
    
    struct key_desc *keyd = file->private_data;
    char label[32] ;
    sprintf(label,"gpio%d",keyd->gpio);

    printk(KERN_DEBUG"gpio_request %d %s\n",keyd->gpio,label);
    gpio_request(keyd->gpio,label);
    gpio_direction_input(keyd->gpio);

    return 0;
}

ssize_t key_read (struct file * file , char __user * user_buf, size_t size, loff_t * off){
 
    struct key_desc *keyd = file->private_data;
    int val = __gpio_get_value(keyd->gpio);
    int len = copy_to_user(user_buf,& val,sizeof(val));
    return sizeof(len);
}
```

