# 多人协作快速迭代：Git 高效工作流方案

针对“多人协作、快速迭代、多次小幅 commit、远程历史简洁、.git 缓存小”的需求，推荐采用基于 **Rebase (变基)** 的工作流。核心思想是：**本地开发随意提交，推送远程前整理历史**。

---

### 1. 开发阶段：随意的高频微提交 (Micro-commits)

在本地开发时，您可以无需顾虑，高频地 commit。比如每写完一个函数、每改好一个 bug 甚至只是想保存进度时就 commit 一次。不要担心产生大量琐碎的 "WIP" (Work In Progress) 提交。

```bash
git commit -m "WIP: 完成了登录框样式"
git commit -m "WIP: 修复了一个变量拼写错误"
git commit -m "WIP: 增加了一些日志"
```

---

### 2. 整理阶段：交互式变基 (Interactive Rebase)

在准备 push 分享代码给同事之前，使用交互式变基将上述琐碎的 commit 合并为一个或几个有意义的逻辑提交。

假设您过去有 5 个琐碎提交，想合并它们：

**@notice** ：使用`git log`命令查看最近的commit，决定合并的commit数量

**@notice** ：-i 参数 调用一个vim窗口来处理 commit log ；`<ver_ptr>=HEAD~5` 指向rebase的新基点为HEAD前5个提交。

@notice ： `rebase <base>` ,base可以是分：

- 分支：将当前分支的基点设置在`<base>`的`HEAD`commit 上
- `HEAD~n`本地分支线性commit下，HEAD前n个提交
- `commit ID` :基于`commit log` 

```bash
git rebase -i HEAD~5
```

这会打开一个编辑器界面，列出最近的 5 个提交。将您想要合并的提交前面的 `pick` 改为 `squash` (或简写 `s`) 或 `fixup` (或简写 `f`)。

*   **pick**: 保留该 commit。对于多个pick，会按照线性pick记录依次保留commit
*   **squash**: 清理这个commit，但把日志消息合并到上一个commit（稍后会让您编辑合并后的消息）。
*   **fixup**: 清理这个commit，不保留这次commit的日志消息（直接丢弃该条 log，常用于修正笔误）。

![image-20260108020054824](C:\Users\yceachan\AppData\Roaming\Typora\typora-user-images\image-20260108020054824.png)

**示例操作：**

```text
pick 1a2b3c 完成用户登录核心逻辑  <-- 保留这个作为主要提交
fixup 4d5e6f 修复拼写错误        <-- 合并进上一条，不留痕迹
squash 7g8h9i 补充单元测试       <-- 合并进上一条，保留这条的说明以便汇总
```

保存并退出编辑器后，Git 会自动帮您合并历史，生成一个整洁的提交历史。

---

### 3. 同步阶段：使用 Rebase 拉取代码

在 push 之前，如果远程主仓库已有更新，使用 `--rebase` 参数拉取，避免产生无意义的 "Merge branch 'main' of..." 合并节点。

```bash
git pull --rebase origin main
```

这会将您的本地新提交“暂时拿下来”，把远程最新的代码“垫在下面”，然后再把您的提交“贴回去”。这样您的提交历史永远是一条直线，非常简洁。

*如果遇到冲突，解冲突后使用 `git add .` 然后 `git rebase --continue` 即可。*

---

### 4. 维护阶段：控制 .git 体积

频繁的 rebase 和重写历史会产生一些“悬空对象”（不再被任何分支引用的旧 commit）。Git 通常会自动清理，但为了确保 `.git` 目录最小，您可以手动运行：

```bash
git gc
```

或者更彻底的清理（耗时较长，建议空闲时运行）：
```bash
git gc --aggressive
```
这会压缩文件版本、移除无用对象，显著减小 `.git` 文件夹体积。

---

### 进阶技巧：Autosquash (自动修整)

如果您想更极致地从提交时就开始规划合并，可以使用 `fixup` 标记：

1.  **先有一个主提交**：`git commit -m "Feature A"`
2.  **发现 bug，修改后提交时指明要修补哪个提交**：
    ```bash
    git commit --fixup <Feature-A-Commit-Hash>
    ```
    (或者指向最近的提交: `git commit --fixup HEAD`)
3.  **在最后整理时，带上 `--autosquash` 参数**：
    ```bash
    git rebase -i --autosquash HEAD~<N>
    ```
    Git 会在编辑器中自动帮您把 `fixup` 的提交排列好并标记为 `fixup` 动作，您只需确认并保存即可，极大地提升了整理速度。