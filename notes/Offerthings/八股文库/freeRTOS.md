# 任务优先级配置

```c
// FreeRTOSConfig.h
#define configMAX_PRIORITIES       16

// task_priorities.h
typedef enum {
    PRIO_IDLE = 0,          // 仅空闲任务
    PRIO_BACKGROUND = 1,    // 后台任务
    PRIO_NORMAL = 4,        // 普通应用任务
    PRIO_HIGH = 8,          // 高响应任务
    PRIO_ISR_HANDLER = 12,  // ISR延迟处理
    PRIO_CRITICAL = 15      // 关键硬实时任务
} TaskPriority_t;
```

# 队列的应用

![image-20251225185143254](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/image-20251225185143254.png)

1. **中断到任务通信**：
   - 必须使用`xQueueSendFromISR()`和`xQueueReceiveFromISR()`
   - 注意处理`xHigherPriorityTaskWoken`参数
   - 数据尽量小，避免长时间占用中断
2. **任务间通信**：
   - 使用`xQueueSend()`和`xQueueReceive()`
   - 合理设置阻塞时间（超时机制）
   - 考虑队列满/空时的处理策略

# FreeRTOS任务调度原理

FreeRTOS是一个实时操作系统，其核心功能之一就是任务调度。任务调度器负责决定在任意给定时刻应该运行哪个任务。FreeRTOS支持多种调度方式，但最常见的是基于优先级的抢占式调度。

## 任务状态

在FreeRTOS中，任务有四种状态：

- **运行态（Running）**：当前正在CPU上执行的任务。
- **就绪态（Ready）**：已经准备就绪，可以运行的任务，但当前没有运行，因为有一个更高优先级的任务正在运行。
- **阻塞态（Blocked）**：任务正在等待某个事件（如信号量、队列、时间延迟等）而暂停运行。
- **挂起态（Suspended）**：任务被显式挂起，不会参与调度，直到被恢复。

## 调度策略

FreeRTOS默认使用基于优先级的抢占式调度。每个任务在创建时都被分配一个优先级（通常为0到configMAX_PRIORITIES-1，数值越大优先级越高）。调度器总是选择处于就绪状态的最高优先级的任务来运行。

- **抢占式**：如果有一个优先级比当前运行任务更高的任务进入就绪状态，那么调度器会立即暂停当前任务，并开始运行更高优先级的任务。
- **时间片**：在相同优先级的任务之间，FreeRTOS可以使用时间片轮转调度（需要配置`configUSE_TIME_SLICING`为1）。每个任务运行一个时间片（通常为1个系统时钟节拍），然后切换到下一个就绪的同优先级任务。

## 调度点

调度器会在以下情况下进行任务切换：

1. 任务主动调用`taskYIELD()`（或使用类似`vTaskDelay`的阻塞函数）。
2. 系统时钟节拍（tick）中断，在中断服务程序中会检查是否需要进行任务切换（例如，时间片用完或延迟到期）。
3. 中断服务程序中释放信号量、队列等，使得更高优先级的任务变为就绪状态。
4. 任务优先级被改变，或者任务被删除、挂起、恢复等。

# 上下文切换

上下文切换是保存当前运行任务的上下文（寄存器状态、堆栈指针等）并恢复下一个要运行任务的上下文的过程。

### 上下文切换的时机

上下文切换发生在调度器决定切换到另一个任务时。具体来说，在以下情况下会发生上下文切换：

- 任务主动放弃CPU（例如调用`vTaskDelay`或`taskYIELD`）。
- 中断服务程序使得更高优先级的任务变为就绪状态（例如释放信号量）。

### 上下文切换的过程

上下文切换的过程依赖于具体的处理器架构，但一般包括以下步骤：

1. **保存当前任务上下文**：将当前任务的寄存器（包括程序计数器、状态寄存器、通用寄存器等）保存到当前任务的堆栈中。
2. **更新任务控制块**：将当前任务的堆栈指针保存到该任务的任务控制块（TCB）中。
3. **选择下一个任务**：调度器从就绪队列中选择最高优先级的任务。
4. **恢复下一个任务上下文**：从下一个任务的TCB中恢复堆栈指针，然后从该任务的堆栈中恢复寄存器的值，包括程序计数器。
5. **切换到下一个任务**：最后，通过恢复的程序计数器跳转到下一个任务继续执行。

### 上下文切换的实现

在FreeRTOS中，上下文切换通常由一个特殊的软件中断或一个专门的上下文切换函数（如`portYIELD()`）触发。在ARM Cortex-M架构中，通常使用PendSV异常来实现上下文切换。

#### 以ARM Cortex-M为例：

- 当需要上下文切换时，会触发一个PendSV异常。
- 在PendSV异常处理程序中，首先保存当前任务的上下文（压入堆栈），然后保存堆栈指针到当前任务的TCB。
- 接着，选择下一个任务，并从其TCB中恢复堆栈指针，然后从堆栈中弹出寄存器，最后通过异常返回指令跳转到新的任务。

这样设计的好处是，上下文切换可以在异常处理程序中完成，并且不会影响中断响应。

# 互斥量优先级反转

![image-20251225155903917](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/image-20251225155903917.png)

# 栈溢出检测

两种堆栈溢出检测方法：

### **方法一**

1. 开启方法：#define configCHECK_FOR_STACK_OVERFLOW 1
2. 检测原理：通过在任务切换时，检测栈顶指针和栈起始指针，或者帧顶指针和栈结束指针是否越界，如果越界，在任务切换的时候触发堆栈溢出钩子Hook函数。

### **方法二**

1. 开启方法：#define configCHECK_FOR_STACK_OVERFLOW 2
2. 检测原理：在任务创建时，将任务栈所有的数据初始化为一个固定值0xa5， 通过任务切换的时候，来判断栈底16个或20个字节是否都为0xa5，如果被修改过，会触发堆栈溢出钩子Hook函数。



**存在的缺点：**

**方法一：**

1. 优点：速度快
2. 缺点：不能检测所有的堆栈溢出，比如任务执行中确实出现了栈顶指针越界的情况，但是在任务切换之前 栈顶指针又指回到了合法位置，这个时候就检测不到栈溢出了。



**方法二：**

1. 优点：速度比方法一慢一点（但对于用户来说还是很快的）
2. 缺点：虽然几乎可以检测到所有的栈溢出情况，但是如果栈溢出时栈溢出值和栈标记值相同，即栈空间最后的几个字节修改完正好都是 0xa5 ，该情况就检测不到栈溢出了；或者压根没用去修改最后几个字节，但是还是溢出了，这个时候也检测不到栈溢出。