MQTT 是基于发布-订阅模式的通信协议，由 MQTT 客户端通过主题（Topic）发布或订阅消息，通过 MQTT Broker 集中管理消息路由，并依据预设的服务质量等级(QoS)确保端到端消息传递可靠性。

**MQTT 客户端**

任何运行 [MQTT 客户端库](https://www.emqx.com/zh/mqtt-client-sdk)的应用或设备都是 MQTT 客户端。例如，使用 MQTT 的即时通讯应用是客户端，使用 MQTT 上报数据的各种传感器是客户端，各种 [MQTT 测试工具](https://www.emqx.com/zh/blog/mqtt-client-tools)也是客户端。

**MQTT Broker**

MQTT Broker 是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。一个高效强大的 MQTT Broker 能够轻松应对海量连接和百万级消息吞吐量，从而帮助物联网服务提供商专注于业务发展，快速构建可靠的 MQTT 应用。

关于 MQTT Broker 的更多详情，请参阅文章 [2025 年最全面的 MQTT Broker 比较指南](https://www.emqx.com/zh/blog/the-ultimate-guide-to-mqtt-broker-comparison)。



客户端们与Broker代理 建立多对一的TCP连接

**发布-订阅模式**

发布-订阅模式与客户端-服务器模式的不同之处在于，它将发送消息的客户端（发布者）和接收消息的客户端（订阅者）进行了解耦。发布者和订阅者之间无需建立直接连接，而是通过 MQTT Broker 来负责消息的路由和分发。

## 工作流程

在了解了 MQTT 的基本组件之后，让我们来看看它的一般工作流程：

1. **客户端使用 TCP/IP 协议与 Broker 建立连接**，可以选择使用 TLS/SSL 加密来实现安全通信。客户端提供认证信息，并指定会话类型（Clean Session 或 Persistent Session）。
2. **客户端既可以向特定主题发布消息，也可以订阅主题以接收消息**。当客户端发布消息时，它会将消息发送给 MQTT Broker；而当客户端订阅消息时，它会接收与订阅主题相关的消息。
3. **MQTT Broker 接收发布的消息**，并将这些消息转发给订阅了对应主题的客户端。它根据 QoS 等级确保消息可靠传递，并根据会话类型为断开连接的客户端存储消息。

# QOS 服务质量保证

> QOS保证的是应用层消息的传达质量，而非TCP会话层的字节流

### 1. QoS 0：最多交付一次

- **别名**：”发完即忘“

- **工作机制**：

  1. 发送者（Publisher）发送消息。
  2. 代理（Broker）收到消息后，立即将其分发给符合条件的订阅者（Subscriber）。
  3. **没有确认机制**。无论 Broker 还是 Subscriber 是否收到，发送方都不会重试。

- **示意图**：

  text

  ```
  Publisher  ---(MSG)-->  Broker  ---(MSG)-->  Subscriber
  （无确认）                 （无确认）
  ```

- **特点**：

  - **优点**：**网络开销最小、传输速度最快**。
  - **缺点**：**可能丢失消息**。消息可能在发送途中、Broker 处理时或下发给订阅者时丢失。

- **典型应用场景**：

  - 周期性的传感器数据上报（如温度、湿度），丢失一次数据影响不大，下次数据很快会覆盖。
  - 非关键的状态指示灯更新。
  - 网络非常稳定、且允许偶发数据丢失的场合。

------

### 2. QoS 1：至少交付一次

- **别名**：”确认交付“

- **工作机制**：

  1. 发送者发送消息，并**保留消息副本**，等待确认。
  2. 接收者（对于 Publisher 是 Broker，对于 Broker 是 Subscriber）收到后，回复一个 **PUBACK** 确认包。
  3. 发送者收到 PUBACK 后，才丢弃消息副本。如果在一段时间内没收到 PUBACK，它会**重新发送**该消息。

- **示意图**：

  text

  ```
  Publisher  ---(MSG)-->  Broker
        <---(PUBACK)---
  Broker ---(MSG)--> Subscriber
       <---(PUBACK)---
  ```

  

- **特点**：

  - **优点**：**可以保证消息不丢失**（因为会重试直到确认）。
  - **缺点**：**可能导致消息重复**。例如，PUBACK 包可能延迟到达，导致发送方误以为失败而重发，接收方就会收到两条相同的消息。**需要应用层处理去重**（通常使用 Message ID）。
  - 网络开销和耗时介于 QoS 0 和 QoS 2 之间。

- **典型应用场景**：

  - **最重要的、最常用的等级**。适用于大多数需要确保消息不丢失，但可以容忍偶尔重复的场景。
  - 重要的状态更新（如设备开关机指令、告警信息）。
  - 交易类指令（如扫码支付请求，需结合业务去重逻辑）。

------

### 3. QoS 2：恰好交付一次

- **别名**：**“保证交付”**
- **工作机制**：这是最复杂、最可靠的等级，通过**四次握手**来确保消息既不丢失也不重复。

  1. **PUBLISH**： 发送者发送消息。
  2. **PUBREC**： 接收者回复“已收到”确认。
     - 至此，接收方已保存消息，但发送方还不能丢弃副本。
  3. **PUBREL**： 发送者收到 PUBREC 后，发送“释放”指令。
  4. **PUBCOMP**： 接收者处理完消息后，发送“完成”确认。发送者此时才安全丢弃副本。
- **特点**：
  - **优点**：**最高可靠性，保证消息不丢失且不重复**。
  - **缺点**：**网络开销最大、交互最慢、需要客户端和服务端存储状态**（在 PUBREC 和 PUBREL 阶段），对资源消耗最大。
- **典型应用场景**：

  - 对重复和丢失都**零容忍**的关键业务。
  - 金融交易确认、计费扣费消息。
  - 固件升级包的传输指令（但固件包本身通常用更底层的可靠传输）。

1. **第一步：PUBLISH（客户端 → 服务端）**

客户端发送：

- **PUBLISH（QoS = 2）**
- 包含：Topic、Payload、Packet Identifier

- 发送消息内容
- 告诉服务端“这是 QoS 2，需要严格确认”

搜索结果指出：PUBLISH 是消息传递的起点。

2. **第二步：PUBREC（服务端 → 客户端）**

​    服务端收到 PUBLISH 后，回复：

- **PUBREC（Publish Received）**



- 是 QoS 2 的**第一步确认**此时服务端进入“收到但未释放”状态。

3.  第三步：PUBREL（客户端 → 服务端）客户端收到 PUBREC 后，发送：

  - **PUBREL（Publish Release）**



  - 客户端告诉服务端：“你可以处理这条消息了”
  - 是 QoS 2 的**第二步确认**此时客户端进入“等待完成确认”状态。

4. **第四步：PUBCOMP（服务端 → 客户端）**服务端处理完消息后，发送：

  - **PUBCOMP（Publish Complete）**


  - 表示“消息处理完成，整个 QoS 2 流程结束”
  - 是 QoS 2 的**第三步确认**客户端收到 PUBCOMP 后，删除本地消息记录。