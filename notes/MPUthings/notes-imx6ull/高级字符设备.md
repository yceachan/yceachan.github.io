# IO模型

用户空间和内核空间具有IO交互

`copy_to_user`

`copt_from_user`

## 1. 阻塞 I/O (Blocking I/O)

![image-20250802144242293](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021442378.png)

## 2. 非阻塞 I/O (Non-blocking I/O)

![image-20250802144421107](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021444177.png)

## 3. I/O 多路复用 (I/O Multiplexing)

- ![image-20250802144607081](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021446156.png)

## 4.信号驱动 I/O (Signal-driven I/O)

![image-20250802144623800](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021446862.png)

## 5. 异步 I/O (Asynchronous I/O)

**真正异步模型**：

- 应用发起 `aio_read()` / `io_uring` 操作
- **内核负责数据准备和复制全过程**
- 操作完成后内核通知应用

# 等待队列 wait_event

## struct

```c
struct __wait_queue { //等待队列项
	unsigned int		flags;
	void			*private;
	wait_queue_func_t	func;
	struct list_head	task_list;
};

struct __wait_queue_head { //等待队列头
	spinlock_t		lock;
	struct list_head	task_list;
};
```



![image-20250802145702531](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021457589.png)

## declare，init

* head

![image-20250802153724709](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021537762.png)

* node

![image-20250802152337666](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021523714.png)

wait_queue_t wait 不由用户管理。见wait event

## wait event

  1. 若 `condition` 为真，直接返回继续下文任务。

  2. **`DECLARE_WAITQUEUE` 并 `init_waitqueue_entry`** , 初始化了 wait

  3. `prepare_to_waite_event(&wq,&__wait)` ，把等待队列项关联到了用户的等待队列头中。

  4. for(;;) 中**轮询**`if(condition) break;`

  5. 若是可中断的等待事件`wait_event_interruptible`，退出循环执行scheduled() 释放cpu 休眠

![image-20250802154518643](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021545705.png)

![image-20250802160402666](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021604708.png)

注：![image-20250802164904638](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021649682.png)

## wait_up

![image-20250802161653878](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021616934.png)

`__wake_up_common`调用唤醒回调函数`cur->func`

![image-20250802161912600](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021619658.png)

这会是一个内核实现的`try_to_wake_up`,**其中包括一行`p->state = TASK_WAKING;`**，**这使得进程被唤醒并继续轮询Condition**

![image-20250802162327572](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021623644.png)

## 附录 tsk->state

![image-20250802163050148](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021630194.png)

![image-20250802162903303](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021629347.png)

## wait queue coding

1. 声明等待队列头wq 
2. 声明Condtion变量
3. wait_event(&wq,&Condtion) or wait_event_interruptible
4. wake_up or wake_up_intteruptible 更新任务配置，并设置Conditon为真

# 阻塞read实现方式

read线程会被阻塞，直到write线程写入数据。

```c
static ssize_t hello_drv_write(struct file * file, const char __user * buf, size_t len, loff_t *offset){
    printk("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
    ret =copy_from_user(hello_buf, buf, len > 1023 ? 1023 : len );
    
    flag =1;
    wake_up_interruptible(&read_wq);
    return len;
}

static ssize_t hello_drv_read(struct file * file,  char __user * buf, size_t len, loff_t *offset){
	//*这里一路都是MARCO FUNCTION，不会有传参过程。函数内能正确地轮询*&flag
    wait_event_interruptible(read_wq, flag);
    
    printk("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
    ret = copy_to_user( buf, hello_buf, len > 1023 ? 1023 : len );

    return len;
}
```

![image-20250802171003174](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021710237.png)

# 非阻塞read实现方式

## 附 file flag

```c
fd = open ("/dev/file",O|RDWR | O_NONBLOCK)
```

flags参数必须包含以下访问模式之一（三选一）：

\- `O_RDONLY`：只读方式打开

\- `O_WRONLY`：只写方式打开

\- `O_RDWR`：随机读写

此外，还可以通过按位或（|）组合以下可选标志：

\- `O_APPEND`：每次写操作都追加到文件末尾

\- `O_CREAT`：如果文件不存在，则创建文件。此时需要提供mode参数。

\- `O_EXCL`：与O_CREAT一起使用，如果文件已存在，则open失败。这可以用于确保创建新文件。

\- `O_TRUNC`：如果文件存在且以可写方式打开，则将其长度截断为0（清空文件）。

\- `O_NONBLOCK`：以非阻塞模式打开文件（对于设备文件和管道特别有用）。

\- `O_SYNC`：使每次write都等待物理I/O操作完成（同步I/O）。

## 应用使用非阻塞特性

```c
//1, 非阻塞打开文件
fd = open ("/dev/file",O|RDWR | O_NONBLOCK)

//2. 轮询目标缓冲区

while(strcmp(buf,"") == 0){
    read(fd,buf,strlen(buf));
    printf(buf);
    sleep(1); //sleep 会 schedule cpu
}
```

## 驱动提供非阻塞读方法

![image-20250802172826995](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508021728090.png)

```c
static ssize_t hello_drv_read(struct file * file,  char __user * buf, size_t len, loff_t *offset){
	if (file->f_flags & O_NONBLOCK) {
		if (!flag) return -EAGAIN;
	}//有数据被写入内核后flag置位，若没有的话返回AGAIN错误码通知用户 
    printk("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
    ret = copy_to_user( buf, hello_buf, len > 1023 ? 1023 : len );

    return len;
}
```

# IO多路复用实现方法——poll

Linux内核提供`seletct`;`poll`;`epoll`三个api来监听多个文件描述符。

`poll`;`select`通过轮询来获取已经准备好的文件描述符

`epoll`将主动轮询编程了被动通知

驱动的`fops`需要完成.`poll()` 接口

`__poll_t (*poll) (struct file *, struct poll_table_struct *);`



## struct pollfd

```c
struct pollfd
  {
    int fd;			/* File descriptor to poll.  */
    short int events;		/* Types of events poller cares about.  */
    short int revents;		/* Types of events that actually occurred.  */
  };
#define POLLIN		0x001		/* There is data to read.  */
#define POLLPRI		0x002		/* There is urgent data to read.  */
#define POLLOUT		0x004		/* Writing now will not block.  */

#define POLLERR		0x008		/* Error condition.  */
#define POLLHUP		0x010		/* Hung up.  */
#define POLLNVAL	0x020		/* Invalid polling request.  */
```

## 应用poll接口

/* Poll the file descriptors described by the NFDS structures starting at
   FDS.  If TIMEOUT is nonzero and not -1, allow **TIMEOUT milliseconds** for
   an event to occur**; if TIMEOUT is -1, block until an event occurs.**
   **Returns the number of file descriptors with events**, **zero if timed out,**
   or **-1 for errors.**

   This function is a cancellation point and therefore not marked with
   __THROW.  */
`extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);`

```c
//1, 头文件
#include <poll.h>
//2 初始化
struct pollfd fds[n]; // n 为要监控的文件描述符数量
for (int i = 0; i < n; i++) {
    fds[i].fd = your_file_descriptor; // 要监控的 fd
    fds[i].events = POLLIN;      // 要监控的事件（POLLIN, POLLOUT 等）
    fds[i].revents = 0;               // 必须初始化为 0
}
//3.poll调用
int timeout = 5000; // 超时时间（毫秒），-1 为阻塞等待
int ready = poll(fds, n, timeout);

//4 处理结果
if (ready == -1) {
    // 错误处理
    perror("poll");
} else if (ready == 0) {
    // 超时处理
} else {
    for (int i = 0; i < n; i++) {
        if (fds[i].revents & POLLERR) {
            // 错误处理
        }
        if (fds[i].revents & POLLIN) {
            // 数据可读处理
        }
        if (fds[i].revents & POLLOUT) {
            // 数据可写处理
        }
        // ... 其他事件处理
    }
}

```

## 驱动实现poll特性

0. `#include <linux/poll.h>`

1. fops提供poll接口
`typedef unsigned __bitwise __poll_t;` 实际为无符号整形,一般返回上边的POLLEVENT即可。
![image-20250802232630639](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508022326724.png)

2. poll方法使用poll_wait api

![image-20250802233651566](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508022336642.png)

\- **`poll_wait`的作用**：它只是将当前进程添加到设备驱动的等待队列中，休眠等待，不发生阻塞。**真正的阻塞发生在`poll`系统调用内部，当没有事件发生时。**

## work flow

![image-20250802234516369](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508022345477.png)

# 信号驱动IO 实现方法 ——SIGIO

信号驱动I/O允许**APP进程**在文件描述符上可进行I/O操作时接收**信号（SIGIO），从而避免轮询**，提高效率。

信号是在软件层次上对中断机制的一种模拟，`kill -l` 显示linux下信号列表

`SIGIO`信号：文件描述符准备就绪, 可以开始进行输入/输出操作.

![image-20250803104434352](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031044471.png)

## work flow

1. **建立信号处理函数：**
   - 应用程序使用 `sigaction()` 或 `signal()`（不推荐）系统调用，为 `SIGIO` 信号注册一个自定义的信号处理函数（`handler`）。这个函数将负责在信号到来时执行实际的 I/O 操作。
2. **设置文件描述符的属主：**
   - 使用 `fcntl(fd, F_SETOWN, getpid())` 告诉内核：“当这个文件描述符 `fd` 上有 I/O 事件发生时，请把 `SIGIO` 信号发送给我的进程（`getpid()` 返回当前进程 ID）”。这样内核才知道信号应该发给谁。
3. **启用文件描述符的异步 I/O 通知：**
   - 使用 `fcntl()` 设置文件描述符的状态标志（`O_ASYNC` 或 `FASYNC`）：
4. **应用程序执行其他任务：**
   - 应用程序的主循环（或主线程）可以去做与 I/O 无关的计算任务、处理其他连接、或者进入睡眠状态（如 `pause()`, `sigsuspend()`, 或在一个循环中检查某个由信号处理函数设置的标志位）。
5. **内核检测 I/O 就绪并发送信号：**
   - 内核持续监视所有被设置了 `O_ASYNC` 标志的文件描述符。
   - 当某个这样的描述符变得可读（对于监听 socket 是有新连接到达，对于已连接 socket/文件是有数据到达内核缓冲区）或可写（发送缓冲区有空间）时（取决于具体实现和需求，有时还需要额外设置），内核会向该描述符的属主进程（在第2步设置的）发送一个 `SIGIO` 信号。
6. **应用处理信号`handler`**

## App

### SIGIO handler

![image-20250803105757520](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031057634.png)

```c
/*********1 singal*********/
//typedef void (*__sighandler_t) (int);
static void SIGIO_irq(int sig){

}
signal(SIGIO, SIGIO_irq);
```

#### 通过fnctl F_SETOWN 配置fd的OWN进程

> 变参函数，... 后边的参数将传递给cmd

![image-20250803112414918](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031124008.png)

![image-20250803112243055](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031122149.png)

```
fcntl(fd, F_SETOWN,getpid());
```

#### 通过fnctl F_SETFL打开file的FASYNC 异步属性

 F_SETFL (int)
              Set  the  file  status  flags  to the value specified by arg.  File access mode (O_RDONLY,
              O_WRONLY, O_RDWR) and file creation flags (i.e., O_CREAT, O_EXCL,  O_NOCTTY,  O_TRUNC)  in
              arg  are ignored.  On Linux, this command can change only the O_APPEND, O_ASYNC, O_DIRECT,
              O_NOATIME, and O_NONBLOCK flags.  It is not possible to  change  the  O_DSYNC  and  O_SYNC
              flags; see BUGS, below.

```c
///两个操作不等价，因为设置FASYNC后的配置过程，必须依赖于FL_OWN属性
	fd = open("/dev/hello_drv", O_RDWR | O_NONBLOCK | O_ASYNC);
    fcntl(fd, F_SETOWN,getpid());
//*必须在执行完F_SETOWN 后再F_SELFL FASYNC
    fd = open("/dev/hello_drv", O_RDWR | O_NONBLOCK);
    fcntl(fd, F_SETOWN,getpid());
	fcntl(fd,F_SETFL,fcntl(fd,F_GETFL) | FASYNC);
```

## DRV

设备维护 `fasync_struct` 的异步通知队列节点的成员 ,在fops.async方法中使用`fasync_helper`加载异步属性，使用`kill_fasync`方法发送SIGIO信号

```c

static struct fasync_struct *fasync_queue;s

static	int hello_drv_fasync (int fd, struct file * file , int on) {
    return fasync_helper(fd, file, on, &fasync_queue);
}
```

### struct fasync_struct

>  异步通知队列 结点

![image-20250803114637697](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031146806.png)

### fasync_helper

```c
int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)
{
	if (!on)
		return fasync_remove_entry(filp, fapp);
	return fasync_add_entry(fd, filp, fapp);
}
```

### kill_fasync 发送SIGIO信号

```c
//* sig:发送的sig信号 ； band: fd事件类型  POLLIN POLLOUT等
void kill_fasync(struct fasync_struct **fp, int sig, int band)
{
	/* First a quick test without locking: usually
	 * the list is empty.
	 */
	if (*fp) {
		rcu_read_lock();
		kill_fasync_rcu(rcu_dereference(*fp), sig, band);
		rcu_read_unlock();
	}
}

static ssize_t hello_drv_write(struct file * file, const char __user * buf, size_t len, loff_t *offset){
    printk("%s %s %d\n", __FILE__, __FUNCTION__, __LINE__);
    ret =copy_from_user(hello_buf, buf, len > 1023 ? 1023 : len );
    flag =1;
    wake_up_interruptible(&read_wq);

	kill_fasync(&fasync_queue, SIGIO, POLLIN);
    return len;
}
```

# Linux内核定时器

1. 基本特征

- **超时驱动**：在指定时间点触发，而非周期性
- **一次性执行**：默认只触发一次，但可在回调中重新注册
- **软中断上下文**：在中断下半部执行，不能睡眠
- **非精确性**：受系统负载影响，可能有轻微延迟

2. 时间单位

- **jiffies**：内核基本时间单位，表示系统启动以来的时钟滴答数

- **HZ**：每秒时钟中断次数（通常100-1000）

- 转换函数：

  ```c
  unsigned long msecs_to_jiffies(unsigned int msecs); // 毫秒转jiffies
  unsigned int jiffies_to_msecs(unsigned long jiffies); // jiffies转毫秒
  ```

## `struct timer_list`

`#include<Linux/timer.h>`

```c

struct timer_list {
	/*
	 * All fields that change during normal runtime grouped to the
	 * same cacheline
	 */
	struct hlist_node	entry;
	unsigned long		expires;  //* 定时终点时刻，单位：Jiffies
	void			(*function)(struct timer_list *);  //*回调函数原型
	u32			flags;

#ifdef CONFIG_LOCKDEP
	struct lockdep_map	lockdep_map;
#endif
};
```

## `DEFINE_TIMER`

```c
//* Linux 4.9
#define DEFINE_TIMER(_name, _function, _expires, _data)		\
	struct timer_list _name =				\
		TIMER_INITIALIZER(_function, _expires, _data)
///_function:
void (*_function)(sigval_t);
struct sigval_t {}


//* Linux 5.4
#define DEFINE_TIMER(_name, _function)				\
	struct timer_list _name =				\
		__TIMER_INITIALIZER(_function, 0)
///_function
compat_uptr_t _function;
typedef u32 compat_uptr_t;
```

![image-20250803133547619](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031335790.png)

## Jiffies

`file:kernel/time/jifffies.h`

系统全局变量，记录自系统运行以来经过的节拍数

```c
/*
 * The 64-bit value is not atomic - you MUST NOT read it
 * without sampling the sequence number in jiffies_lock.
 * get_jiffies_64() will do this for you as appropriate.
 */
extern u64 __jiffy_data jiffies_64;
extern unsigned long volatile __jiffy_data jiffies;
```

- 在`asm-generic/parm.h` 中能找到`Internal Kernel timer frequency`

![image-20250804121804052](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508041218178.png)

* convert api

![image-20250803133446751](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031334866.png)

## API: add del mod

![image-20250803134015627](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031340786.png)

```c
extern void add_timer(struct timer_list *timer);
extern int del_timer(struct timer_list * timer);
extern int mod_timer(struct timer_list *timer, unsigned long expires);
```

## work flow

![image-20250803134643626](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031346791.png)

# lseek

SYNOPSIS
```c
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);

//arg of whence:
SEEK_SET
              文件偏移量设置为偏移字节。

SEEK_CUR
              文件偏移量设置为其当前位置加上偏移量字节。

SEEK_END
              文件偏移量设置为文件大小加上偏移量字节。
```

## 驱动fops.lseek接口

```
static loff_t my_llseek(struct file *file, loff_t offset, int whence)
{
    struct my_device *dev = file->private_data;
    loff_t newpos;

    switch (whence) {
        case SEEK_SET: // 从文件头开始
            newpos = offset;
            break;
        case SEEK_CUR: // 从当前位置开始
            newpos = file->f_pos + offset;
            break;
        case SEEK_END: // 从文件末尾开始
            newpos = dev->size + offset;
            break;
        default:
            return -EINVAL; // 无效参数
    }

    // 检查边界
    if (newpos < 0 || newpos > dev->size)
        return -EINVAL;

    // 更新文件位置
    file->f_pos = newpos;
    return newpos;
}
```

## read write 配套实现offset

```c
//read要更新用户空间的f_pos
static ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
    struct my_device *dev = filp->private_data;
    ssize_t retval = 0;
    
    mutex_lock(&dev->lock);
    
    // 计算实际可读数量
    if (*f_pos >= dev->size)
        goto out;
    
    if (*f_pos + count > dev->size)
        count = dev->size - *f_pos;
    
    // 复制数据到用户空间
    if (copy_to_user(buf, dev->data + *f_pos, count)) {
        retval = -EFAULT;
        goto out;
    }
    
    *f_pos += count;
    retval = count;

out:
    mutex_unlock(&dev->lock);
    return retval;
}
//*write要从f_ops位置写入
static ssize_t my_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
{
    struct my_device *dev = filp->private_data;
    ssize_t retval = 0;
    
    mutex_lock(&dev->lock);
    
    // 检查空间
    if (*f_pos + count > MAX_SIZE) {
        retval = -ENOSPC;
        goto out;
    }
    
    // 扩展数据区
    if (*f_pos + count > dev->size) {
        dev->size = *f_pos + count;
    }
    
    // 从用户空间复制数据
    if (copy_from_user(dev->data + *f_pos, buf, count)) {
        retval = -EFAULT;
        goto out;
    }
    
    *f_pos += count;
    retval = count;

out:
    mutex_unlock(&dev->lock);
    return retval;
}
```

# ioctl

write 和 read 主要是对数据流的操作，对硬件的控制能力更适合使用ioctl 接口

![image-20250803144313821](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031443943.png)

## request /cmd

--------------------------


| 31 \- 30 (2) | 29 \- 16 (14) | 15\- 8(8) | 7 \- 0 (14) |
|----------|----------|--------|-------|
| dir 方向 | size arg的sizeof | nr 命令序号 | type  字符字面量，标识对应设备 |


-----------

![image-20250803151507604](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031515712.png)

- dir ： 0=NONE ; 1=W ; 2= R ; 3=WR

- size参数 填入 arg的数据类型 e.g. `int`，这将传递`sizeof (int)`

![image-20250803145017273](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508031450382.png)

* 命令设计示例

```c
// 驱动头文件 mydevice.h
#ifndef MYDEVICE_H
#define MYDEVICE_H

#include <linux/ioctl.h>

#define type 'k' // 幻数 (0-255)

// 定义命令
#define MYDEVICE_RESET _IO(type, 0)
#define MYDEVICE_SET_VALUE _IOW(type, 1, int)
#define MYDEVICE_GET_VALUE _IOR(type, 2, int)
#define MYDEVICE_SET_CONFIG _IOW(type, 3, struct device_config)

// 此时 size = sizeof(struct my_data)
#define MY_CMD _IOW('M', 1, struct my_data)


// 最大命令号
#define MYDEVICE_MAX_CMD 3

#endif
```

## 驱动fops.unlocked_ioctl 接口

在 `struct file_operations` 中：

```c
//*ioctl不再被使用
long (*unlocked_ioctl) (struct file *filp, unsigned int cmd, unsigned long arg);
//64为兼容32位接口
long (*compat_ioctl) (struct file *filp, unsigned int cmd, unsigned long arg); // 32
```

## copy_form/to_user 传参

这两个api都是`memset`级别的传递

```c
extern __must_check unsigned long
_copy_to_user(void __user *, const void *, unsigned long);
#endif

static __always_inline unsigned long __must_check
copy_from_user(void *to, const void __user *from, unsigned long n)
{
	if (likely(check_copy_size(to, n, false)))
		n = _copy_from_user(to, from, n);
	return n;
}
```

- **arg 是用戶传递的参数的基地址**，配合约定号的数据类型，cmd.size 确定大小，将其强制转化为对应指针，配合copy api 即可对用户空间的参数进行ioctl

```c
struct arg {
	int a,b,c
};
#define DRV_CMD_READ  _IOR('a',1,struct arg)

static	long  hello_drv_ioctl (struct file * file , unsigned int cmd , unsigned long arg) {
    struct arg kernData={1,2,3};
    struct arg *puserData= (struct arg *) arg;

    if(cmd == DRV_CMD_READ) {
		copy_to_user(puserData, & kernData, sizeof (struct arg);)
	}
	return 0;
}
```

# Debug-Dumpstack

`dump_stack()` 是 Linux 内核中一个强大的调试函数，用于打印当前 CPU 的执行堆栈跟踪信息。它在内核开发和调试中起着至关重要的作用，特别是在诊断内核崩溃、死锁和意外行为时。

## 一、dump_stack() 的核心功能

### 1. 核心作用

- **堆栈跟踪**：显示当前执行路径的函数调用序列
- **上下文信息**：提供处理器状态、寄存器值和内存内容
- **诊断辅助**：帮助定位内核 panic、oops、死锁等问题
- **动态调试**：可在代码任意位置插入，无需重新编译
