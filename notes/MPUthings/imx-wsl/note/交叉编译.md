* main函数传参

![image-20250306225831444](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503062258514.png)

* agcc /gcc 生成可执行文件差异

![image-20250306230236223](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503062302277.png)

# GCC

编译选项：            

| 参数        | description                                        | 作用                           | 工具            |
| ---- | ---- | ---- | ---- |
|  -E （大写）  |  Preprocess only; do not compile, assemble or link.    | 预处理，查找头文件，展开宏， | 文本编辑 |
|   -S (大写)   |   Compile only; do not assemble or link.   | 编译，生成汇编码.s | cc1 （collect） |
|    -c  | Compile and assemble, but do not link.     | 汇编，生成.o OBJ单元（机器码） | as（assemble） |
|  -o <file>    |   Place the output into <file>.   | 指定输出文件 |                 |
| gcc | gcc <1.o> <2.o>  -o <outputfile> | 链接，生成elf可执行文件 | ln(link)        |
| -v |  | 展示编译过程细节 |                 |





| 参数                    | 作用                                                       |
| ----------------------- | ---------------------------------------------------------- |
| -Wall                   | 打开warning                                                |
| -g                      | 打开调试                                                   |
| -l<library>             | 链接名为 library 的库文件,库文件的真正名字是`liblibrary.a' |
| -L<path>                | 指定库文件搜索目录                                         |
| -i<path> （小写，紧邻） |                                                            |
| -I <path>> (大写，空格) |                                                            |
| -nostdlib               | 不链接系统标准启动文件和标准库文件                         |
| -static                 | 阻止链接共享库。                                           |
| -shared                 | 生成动态库 （约定后缀.so）                                 |

## 制作动态库 `gcc -shared`

**动态库在程序运行时才被加载，它们通常有 *.so* 或 *.dll* 扩展名。**

![image-20250307000501506](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070005686.png)

## 制作静态库 `ar压缩程序`

**静态库是在程序编译时一起打包进可执行文件的库。它们通常有 *.a* 或 *.lib* 扩展名。**

![image-20250307000519400](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070005499.png)

# Makefile

```
##语法模板
target : dependence        //会比较target 与 dpendence的版本差异，若依赖文件较新，执行以下action
 <tab>action //action 每行缩进必须为tab
hello : main.c src1.c
  gcc *.c -o app
```

```
#一个高校的make模板
.PHONY: clean all   //将clean、all视为伪目标
app: *.o
	gcc *.o -p app
src1.o: src1.c
	gcc -c src1.c //-c 默认生成.o OBJ单元
src2.o: src2.c
	gcc -c src2.c //-c 默认生成.o OBJ单元
clean :           //目录下不能有名为clean文件
	rm -f *.o app
	
all : src1.o src2.o app   //当依赖其他target时，会调用其他target的依赖检查
```



```
##好用的特性
hello world : *.o       //相同依赖和动作的target 可写在一行
	@echo "all done"    //命令前加@，不打印命令结果
	gcc *.o -o $@       //$@ 为当前target
```

```
#变量操作
## $@ :当前目标target
## $< :第一个依赖文件
## $^ :所有依赖文件
targets = hello world
src =src1.c src2.c
obj =src1.o src2.o
CFLAGS -Wall -g -o2

all : $(targets) //$展开变量
	@echo "all done"
$(targets) : $(obj)  
	gcc $(obj) -o $@
	
%.o ：%.c       //自动通配（src1.o src2.o 目标被 $(targets)目标依赖
	gcc $(CFLAGS) -c $< -o $@  //输入第一个依赖文件（%.c） ，输出文件名为target (%.o)
```

# Cmake

[披着clion的外衣实则在讲cmake（）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18R4y127UV/?spm_id_from=333.337.search-card.all.click&vd_source=d8c39ae6749f658d0698389713f47409)

## Clion set的作用

* 为Cmake配置运行时的环境变量

![image-20250307023500525](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070235678.png)



* 为Cmake 传一些写在CmakeList外的参数

![](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070236387.png)

## Vscode set

> 通过 quick start想到，可以配置出如下的预设置
>
> 注意，generator 尽量在preconfig 中完成

![image-20250307041456950](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070414036.png)

## 循环、分支结构

![image-20250307023900103](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070239307.png)![image-20250307032806140](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070328203.png)

## cmake 命令

![image-20250307033513333](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070335431.png)

* 常用命令讲解：

`cmake_minimum_required` 命令：规定了编译本项目的cmake工具至少需要版本。



`project` 命令：规定了本项目的项目名称，同时也根据这个传入的值生成了一堆变量，常用的如下：

1. `PROJECT_NAME` ：项目名称
2. `PROJECT_BINARY_DIR` ：项目的二进制文件目录，即编译后的可执行文件和库文件的输出目录
3. `PROJECT_SOURCE_DIR` ：项目的源文件目录，即包含CMakeLists.txt文件的目录



`set` 命令：设置对应变量为对应的值，该变量存在，则修改该变量的值，如果不存在则会创建并初始化为对应的值，这里对set的使用是设置了 CMAKE_CXX_STANDARD 变量为17，这个变量可以控制最终编译采用的C++版本，这里是使用C++17。



`add_executable` 命令：这是用于生成可执行程序的命令，第一个参数为该执行程序最终编译后生成的文件名，后面跟着的都是需要编译的源代码。



### file

> ![image-20250307032330008](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070323117.png)

### file(GLOB \<var\> \<expr\> )

将expr 中所有文件添加到 var变量中

#Generate a list of files that match the <globbing-expressions> and store it into the <variable>.

![image-20250307032444178](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070324234.png)

### aux_source_directory

![image-20250307032635935](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202503070326016.png)

## package

[find_package](https://link.juejin.cn/?target=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Flatest%2Fcommand%2Ffind_package.html%23id5)：用于查找外界的package，其实就是查找外界对应的 `<package>Config.cmake` 和 `Find<package>.cmake` 文件

[include](https://link.juejin.cn/?target=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Flatest%2Fcommand%2Finclude.html)：从文件或模块加载并运行 CMake 代码。我用这个命令实际上只是为了使用 [FetchContent](https://link.juejin.cn/?target=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Flatest%2Fmodule%2FFetchContent.html%23id1)[¶](https://link.juejin.cn/?target=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Flatest%2Fmodule%2FFetchContent.html%23fetchcontent) 这个module的功能，该功能是从cmake3.11开始支持的，使用该module前需要通过include命令加载该模块，命令如下
