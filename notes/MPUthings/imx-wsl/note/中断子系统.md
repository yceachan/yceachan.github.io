# 中断控制器GIC概述

![image-20250803230347299](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508032303364.png)

**GIC 是什么？**

- **全称：** Generic Interrupt Controller (通用中断控制器)
- **角色：** 它是 ARM 架构中**标准化**、**集中式**管理所有硬件中断请求的**硬件 IP 模块**。
- **核心职责：** 接收系统中来自各种外设、处理器核间通信、软件触发的中断信号，进行仲裁、优先级排序、分发、状态管理，并将最高优先级且已使能的中断送达给目标 CPU 核心进行处理。
- **重要性：** 对于实现高效、可靠、可扩展（尤其是多核系统）的中断处理至关重要。它是 ARM 系统中断处理的**中枢神经系统**。几乎所有基于 ARM Cortex-A 和 Cortex-R 处理器的 SoC 都集成了 GIC。



## 硬件视角

1. **中断源 (Interrupt Sources):**
   - **软件生成中断 (SGI):** `0-15`。由软件（通常一个 CPU 写 GICD_SGIR 寄存器）触发，主要用于**核间通信**。例如，唤醒其他核心、发送 IPI。
   - **私有外设中断 (PPI):** `16-31`。特定于**某个 CPU 核心**的中断。常见的有：
     - 每个核心的私有定时器中断 (`27`)
     - 每个核心的看门狗定时器中断 (`28`)
     - 性能监控单元中断 (`29`)
   - **共享外设中断 (**Shared Peripheral Interrupt **SPI):** `32-1019` (具体最大数量取决于实现)。**全局共享**的中断源，可以路由到系统中的**任何**一个或多个 CPU 核心。这是大多数外设中断（如 UART, I2C, USB, Ethernet, DMA, GPU）所属的类型。
   - **特定实现的中断 (ID 1020-1023):** 保留给具体实现使用。
   - **基于消息的中断 (LPI - Locality-specific Peripheral Interrupt) (仅 GICv3/v4):** `8192+`。一种**无物理连线**的中断，通过**写内存地址**（通常是 GITS_TRANSLATER 寄存器）来触发。主要服务于 PCIe MSI/MSI-X。其配置（优先级、目标、使能）存储在**内存表**中，而不是 GIC 寄存器中，非常灵活且可扩展。LPI **总是**是**边沿触发**的。
2. **分发器 (Distributor - GICD):**
   - **角色：** GIC 的**全局控制中心**。主要处理 `Shared Peripheral Interrupt`SPI，也参与 SGI/PPI 的全局配置。
   - **核心功能：**
     - **全局中断使能/禁用：** 控制整个 GIC 是否分发中断。
     - **单个中断使能/禁用：** 控制每个中断源是否可以被分发。
     - **中断优先级配置：** 为每个中断设置优先级 (通常是 8-bit 或更多)。
     - **中断目标配置 (SPI):** 指定每个 SPI 可以发送到哪些 CPU 核心（或一组核心）。
     - **中断触发类型配置：** 配置中断是电平敏感 (Level-sensitive) 还是边沿触发 (Edge-triggered) (主要针对 SPI 和 PPI，SGI 总是边沿触发，LPI 总是边沿触发)。
     - **中断状态管理：** 跟踪每个中断的挂起 (Pending)、激活 (Active) 状态。
     - **中断安全状态配置：** 将中断分配到 Group 0 (安全, FIQ) 或 Group 1 (非安全, IRQ)，配合 TrustZone。
     - **中断挂起/清除：** 软件可以设置或清除挂起状态。
   - **访问：** 所有 CPU 核心通常都可以访问 Distributor 寄存器 (通过内存映射 I/O)，但某些寄存器访问可能需要安全权限。
3. **CPU 接口 (CPU Interface - GICC):**
   - **角色：** 位于**每个 CPU 核心**和 Distributor/Redistributor 之间，是 CPU 核心与 GIC **直接交互**的接口。
   - **核心功能：**
     - **CPU 核心中断使能/禁用：** 全局控制该 CPU 是否接收中断 (类似于 CPSR 的 I/F 位，但更底层)。
     - **中断优先级掩码：** 设置该 CPU 能响应的**最低优先级**。优先级高于此值的中断才会被 CPU 感知。用于实现优先级抢占。
     - **中断优先级提升：** 软件可以临时提升运行任务的优先级，防止被低优先级中断打断 (抢占阈值)。
     - **中断应答 (Acknowledge):** CPU 读取 `GICC_IAR` 寄存器来**认领**当前最高优先级挂起中断，获取其 ID。这是中断服务程序的第一步。
     - **中断完成 (End of Interrupt):** CPU 在处理完中断后，写入 `GICC_EOIR` 寄存器告知 GIC。这将清除该中断在 CPU 接口的激活状态，并可能允许分发优先级较低但被屏蔽的中断。
     - **运行优先级：** 指示当前 CPU 正在服务的中断的优先级。
   - **访问：** 每个 CPU 核心通过**专属的**内存映射地址访问自己的 CPU Interface 寄存器。
4. **再分发器 (Redistributor - GICR) (仅 GICv3/v4):**
   - **角色：** 在 GICv3/v4 中引入，**分担**了 Distributor 的部分功能，特别是与**特定 CPU 核心**紧密相关的功能 (PPI, SGI, LPI)。它通常**物理上更靠近**其服务的 CPU 核心或 CPU 簇。
   - **核心功能 (主要针对其关联的 CPU):**
     - **处理 PPI 和 SGI:** 管理发送给或来自其关联 CPU 的 PPI 和 SGI 的配置和状态。
     - **处理 LPI:** **关键组件！** 管理发送给其关联 CPU 的 LPI 的配置和状态。它包含指向 LPI 配置表 (存储优先级、使能状态) 和 LPI 挂起表 (存储挂起状态) 的指针。
     - **唤醒管理：** 管理与其关联 CPU 的电源状态相关的唤醒事件。
   - **访问：** 通常每个 CPU 核心可以访问自己的 Redistributor 寄存器 (通过内存映射 I/O)。Distributor 也会访问 Redistributor 进行全局协调。
5. **中断翻译服务 (ITS - Interrupt Translation Service) (可选组件，仅 GICv3/v4):**
   - **角色：** 专为管理和路由 **LPI** 中断而设计。它**翻译**设备发出的 MSI 请求（包含设备 ID 和事件 ID）**转换**为对应的 LPI ID 和其目标 Redistributor (即目标 CPU)。
   - **核心功能：**
     - **维护翻译表：** 在内存中维护设备表 (Device Table)、中断翻译表 (Interrupt Translation Table) 等，建立 `(DeviceID, EventID) -> (LPI ID, Target Redistributor)` 的映射关系。
     - **处理 MSI 写操作：** 监听特定内存地址范围 (通常是 `GITS_TRANSLATER`)，当设备执行 MSI 写操作时，ITS 根据写入的 `DeviceID` 和 `EventID` 查表，生成对应的 LPI 发送给目标 Redistributor。
   - **重要性：** 对于高效支持大量 PCIe 设备及其 MSI/MSI-X 中断至关重要。没有 ITS，系统只能使用传统的 SPI 来模拟 MSI，效率低下且占用宝贵的 SPI ID。

### SOC GIC Platform

![image-20250803231755163](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508032317248.png)

## 软件视角 GIC 的配置与使用

1. **初始化:**
   - 探测 GIC 版本和硬件特性 (寄存器基地址、支持的中断数、LPI/ITS 支持等)。
   - 全局禁用 Distributor (`GICD_CTLR`)。
   - 禁用所有中断源 (`GICD_ICENABLERn`)。
   - 配置所有中断的默认触发类型 (`GICD_ICFGRn`)，优先级 (`GICD_IPRIORITYRn`)，目标 (SPI, `GICD_ITARGETSRn`)，安全组 (`GICD_IGROUPRn` / `GICD_IGRPMODRn`)。
   - (GICv3/v4) 配置 Redistributors 和 ITS (如果存在)，初始化 LPI 配置表/挂起表。
   - 全局启用 Distributor。
   - 为每个 CPU 核心：
     - 配置其 CPU Interface 的优先级掩码 (`GICC_PMR`) 和抢占阈值 (`GICC_BPR`)。
     - 启用 CPU Interface (`GICC_CTLR`)。
2. **注册中断处理程序 (ISR):**
   - 操作系统维护一个中断描述符表 (IDT) 或类似结构，将中断 ID 映射到对应的驱动 ISR 函数。
   - 对于特定外设中断，驱动调用操作系统 API 注册其 ISR (提供中断 ID 和函数指针)。
3. **启用特定中断:**
   - 外设驱动在准备好后，通过**写 Distributor 的 `GICD_ISENABLERn` 寄存器使能其负责的中断。**
4. **中断处理流程 (在 CPU 核心上):**
   1. 硬件检测到 CPU Interface 有待处理的中断。
   2. 硬件暂停当前程序执行，保存上下文，跳转到**异常向量表**中的 IRQ/FIQ 入口。
   3. **通用 IRQ/FIQ 入口代码：**
      - 读取 `GICC_IAR` 获取**中断 ID (INTID)**。
      - 根据 INTID 查找对应的 ISR。
      - 调用该 ISR。
      - ISR 执行，处理中断事件 (例如，读取 UART 接收寄存器)。
      - 写入 `GICC_EOIR` 告知 GIC 中断处理完成，传递之前读取的 INTID (或 EOI 寄存器要求的其它值)。
   4. 恢复上下文，返回到被中断的程序继续执行。

### 中断号 (INTID/IRQ#) 

**类型与分区：** GIC 将 INTID 划分为几个关键区域，每种类型的中断有固定的 ID 范围：、

 **特定于某个 CPU 核心**的中断。每个核心都有自己独立的一套 PPI。

- **软件生成中断 (SGI):** `0 - 15`
- **私有外设中断 (PPI):** `16 - 31`
  - **INTID 27:** 每个核心的私有定时器 (Core Private Timer)。
  - **INTID 28:** 每个核心的看门狗定时器 (Core Watchdog)。
  - **INTID 29:** 性能监控单元中断 (PMU)。
- **共享外设中断 (SPI):** `32 - 1019` (GICv2/v3) / `32 - 最大支持值` (通常远小于 1019)

  - **用途：** **全局共享**的中断源，可以路由到系统中的**任何**一个或多个 CPU 核心。

* **基于消息的中断 (LPI - Locality-specific Peripheral Interrupt) (仅 GICv3/v4):** `8192 - 16383`

  - **用途：** 一种**无物理连线**的中断，主要服务于 PCIe 设备使用的 MSI/MSI-X。通过**写特定的内存地址**来触发。

# SPI-共享外设中断

## Work Flow

**阶段 1：硬件中断触发**

- 中断信号通过 SoC 的布线连接到 **仲裁器** GIC Distributor (**GICD**) 的特定 SPI 输入引脚（例如 `SPI #116`）。

**阶段 2：GIC 中断处理（硬件层）**

1. **Distributor 处理中断**
   - GICD 检测到中断信号，根据配置：
     - 检查该中断是否被使能（`GICD_ISENABLERn`）。
     - 检查触发类型（电平/边沿，`GICD_ICFGRn`）。
     - 设置中断状态为 **Pending**（挂起）。
   - 对当前所有 Pending 中断进行 **优先级仲裁**（比较 `GICD_IPRIORITYRn` 的值）。
   - 根据 **目标 CPU 掩码**（`GICD_ITARGETSRn`）选择接收中断的 CPU 核心（例如 CPU0）。
2. **分发至目标 CPU Interface**
   - GICD 将最高优先级的 Pending 中断（假设 `SPI #116`）发送给目标 CPU 的 **CPU Interface** (**GICC**)。
3. **CPU Interface 通知 CPU 核心**
   - GICC 检查：
     - CPU 是否全局使能中断（`GICC_CTLR`）。
     - 中断优先级是否高于 CPU 当前优先级掩码（`GICC_PMR`）。
   - 若条件满足，GICC 通过 `nIRQ` 引脚向 CPU 核心发送物理中断信号。

**阶段 3：CPU 核心响应中断（ARM 架构层）**

1. **CPU 接管中断**
   - CPU 执行完当前指令后，检测到 `nIRQ` 信号有效。
   - 硬件自动完成以下操作：
     - 保存当前程序状态（`CPSR` 复制到 `SPSR_irq`）。
     - 切换到 **IRQ 模式**，跳转到预设的 **异常向量表地址**（如 `0xFFFF0018`）。
     - 关闭中断（设置 `CPSR.I` 位）。
2. **执行异常向量代码（在汇编代码中被定义）**
   - CPU 执行位于 `irq` 向量入口的汇编代码（通常为 `b handle_arch_irq`）。
   - 该函数指向 GIC 驱动注册的入口（如 `gic_handle_irq`）。

**阶段 4：Linux 内核通用中断处理（C 语言层）**

1. **GIC 驱动入口 (`gic_handle_irq`)**
   - 读取 `GICC_IAR` 寄存器，获取 **硬件中断号（INTID）**（例如 `116`）。
   - 将 INTID 转换为 Linux 的 **虚拟中断号（virq）**（通过 `irq_domain` 映射）。
   - 调用通用中断处理入口 `generic_handle_irq(virq)`。
2. **中断流控处理 (`handle_irq_event`)**
   - 内核根据中断类型（电平/边沿）执行流控操作：
     - **电平中断**：先 Mask 中断（防止重复触发），再调用具体 handler。
     - **边沿中断**：直接调用 handler。

**阶段 5：驱动中断处理程序执行（回调层）**

1. **调用驱动注册的 Handler**

   - 内核遍历该中断号注册的 `irqaction` 链表，依次调用驱动注册的回调函数：

     ```c
     // 驱动注册示例
     request_irq(virq, my_device_isr, IRQF_SHARED, "my-device", dev);
     ```

   - 执行 `my_device_isr(irq, dev_id)`：

     - 读取外设状态寄存器（如 UART 的 `UART_MISR`）。
     - 判断具体中断原因（如“接收数据就绪”）。
     - 处理数据（如从 FIFO 拷贝数据到内存缓冲区）。
     - 清除外设中断标志（写状态寄存器）。

**阶段 6：中断结束处理** cpu恢复现场

## request_irq()

- 函数原型

```c
int request_irq(unsigned int irq, 
                irq_handler_t handler, 
                unsigned long flags,
                const char *name, 
                void *dev_id);
```

- 参数详解

| **参数**  | **类型**        | **作用**                                                     |
| :-------- | :-------------- | :----------------------------------------------------------- |
| `irq`     | `unsigned int`  | **Linux 虚拟中断号**（非硬件 INTID），由平台总线或设备树解析得到，e.g api :`gpio_to_irq` |
| `handler` | `irq_handler_t` | **中断处理函数**，原型：`irqreturn_t (*)(int irq, void *dev_id)` |
| `flags`   | `unsigned long` | **中断标志**，控制中断行为（触发方式、共享等）               |
| `name`    | `const char *`  | **中断名称**，显示在 `/proc/interrupts` 中（调试关键）       |
| `dev_id`  | `void *`        | **设备标识**，传递给 `handler`，通过空类型指针 传递 `dev_desc` |

- FLAG  掩码操作

  | **标志**               | **作用**                                                     |
  | :--------------------- | :----------------------------------------------------------- |
  | `IRQF_TRIGGER_RISING`  | 上升沿触发                                                   |
  | `IRQF_TRIGGER_FALLING` | 下降沿触发                                                   |
  | `IRQF_TRIGGER_HIGH`    | 高电平触发                                                   |
  | `IRQF_TRIGGER_LOW`     | 低电平触发                                                   |
  | `IRQF_SHARED`          | **共享中断**（多个设备共用同一中断线时必需）                 |
  | `IRQF_ONESHOT`         | 线程化中断中，处理完成前不重新启用中断                       |
  | `IRQF_THREADED`        | **中断线程化**（将 handler 放入内核线程执行，解决实时性需求） |

- irq： `gpio_to_irq`

```c
//使用int 标识gpio号，返回其在设备树/plat 编码的中断号
static inline int __gpio_to_irq(unsigned gpio)
{
	return gpiod_to_irq(gpio_to_desc(gpio));
}

```

* void *dev_id  --> struct gpio_desc

`struct gpio_desc` 是一个核心数据结构，用于抽象描述一个具体的GPIO引脚。其设计遵循了Linux驱动模型中的“消费者-提供者”规范（Consumer-Provider），**旨在统一GPIO的操作接口，同时屏蔽底层硬件差异。**

在`libgpio.c`中有一份标准实现

```c
struct gpio_desc {
	struct gpio_device	*gdev;
	unsigned long		flags;
/* flag symbols are bit numbers */
#define FLAG_REQUESTED	0
#define FLAG_IS_OUT	1
#define FLAG_EXPORT	2	/* protected by sysfs_lock */
#define FLAG_SYSFS	3	/* exported via /sys/class/gpio/control */
#define FLAG_ACTIVE_LOW	6	/* value has active low */
#define FLAG_OPEN_DRAIN	7	/* Gpio is open drain type */
#define FLAG_OPEN_SOURCE 8	/* Gpio is open source type */
#define FLAG_USED_AS_IRQ 9	/* GPIO is connected to an IRQ */
#define FLAG_IS_HOGGED	11	/* GPIO is hogged */

	/* Connection label */
	const char		*label;
	/* Name of the GPIO */
	const char		*name;
};

```

用户可以提供一套差异化实现

```c
struct gpio_desc {
	int gpio;
	int irq;
    char *name;
    int key;
	struct timer_list key_timer;
} ;
```

**Consumer 统一接口**：通过 `gpiod_*()` API 操作抽象描述符。

![image-20250804121211221](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508041212329.png)

### user_isr (可传参)

```c
//statement  void* 是一个灵活的传参对象
typedef irqreturn_t (*irq_handler_t)(int, void *);

//这里传递一个gpio_desc ，是gpiolib 的规范接口
static irqreturn_t gpio_key_isr(int irq, void *dev_id)
{
	struct gpio_desc *gpio_desc = dev_id;
	printk("gpio_key_isr key %d irq happened\n", gpio_desc->gpio);
	mod_timer(&gpio_desc->key_timer, jiffies + HZ/5);
	return IRQ_HANDLED;
}
//return type 
typedef enum irqreturn irqreturn_t;
enum irqreturn {
	IRQ_NONE		= (0 << 0),
	IRQ_HANDLED		= (1 << 0),
	IRQ_WAKE_THREAD		= (1 << 1),
};
```

## gpio 中断总结

1.用户驱动可以借助内核的gpiolib 操作gpio，只需提供 `int gpio` 一个gpio号即可实现。无需进行初始化等配置

`   gpio_set_value(gpios[ker_buf[0]].gpio, ker_buf[1]);`

`val = gpio_get_value(gpio_desc->gpio);`

gpio 号在设备树、Platform总线等地方被定义

2. 使用request_irq 为gpio 配置中断

`err = request_irq(gpios[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, "100ask_gpio_key", &gpios[i]);`

3. 实现回调`usrirq`

# 附 Linux 内核 IRQ 中断号管理

Linux 内核管理中断号（IRQ）是一个分层、高度抽象的复杂过程，涉及硬件描述、中断路由、软件抽象和性能优化。以下是其核心机制和实现细节的深度解析

### 核心数据结构解析

-  1. 中断描述符 `struct irq_desc` (核心枢纽)

```c
// include/linux/irqdesc.h
struct irq_desc {
    struct irq_common_data  irq_common_data;
    struct irq_data         irq_data;       // 硬件相关数据
    irq_flow_handler_t      handle_irq;     // 流控处理函数
    struct irqaction        *action;        // 驱动注册的 ISR 链表
    unsigned int            depth;           // 禁用嵌套计数
    unsigned int            irq_count;       // 中断计数
    const char              *name;           // /proc/interrupts 显示名
    // ...etc
};
```

-  2. 硬件关联结构 `struct irq_data`

```c
//include/linux/irq.h
struct irq_data {
    u32                     mask;           // 中断掩码
    unsigned int            irq;            // Linux 虚拟 IRQ
    struct irq_chip         *chip;          // 底层硬件操作集
    struct irq_domain       *domain;        // 中断域（映射关键）
    // ...
};
```

- 3. 驱动注册结构 `struct irqaction *action`


```c
struct irqaction {
    irq_handler_t           handler;        // 驱动 ISR 函数
    void                    *dev_id;         // 设备标识符
    struct irqaction        *next;           // 共享中断链表
    unsigned int            irq;             // 注册的虚拟 IRQ
    unsigned int            flags;           // IRQF_* 标志
    const char              *name;           // 设备名
    // ...
};
```

### IRQ 生命周期管理

- 阶段 1：启动初始化

**硬件 → 物理 IRQ 注册：**

1. 中断控制器驱动（如 GIC）初始化
2. 调用 `irq_domain_add_linear()` 注册中断域
3. 建立物理 IRQ → 虚拟 IRQ 映射

- 阶段 2：设备树 中断号分配与映射

- 阶段 3：驱动中断注册
   - request_irq
     - 内核内部操作：

       查找 irq_desc[virq]  || 动态方法：	desc = irq_to_desc(irq);

       创建 irqaction 并加入链表

       配置底层硬件：

# 中断下文机制 bottom half

在中断服务程序(ISR)的**上半部（Top Half）的限制**：

1. **不可休眠**：禁止调用可能阻塞的函数 (`kmalloc(GFP_KERNEL)`, `mutex_lock()` 等)
2. **不可调度**：当前执行线程不能被抢占
3. **时间敏感**：执行时间需极短（通常 < 100μs）

不适合执行长耗时的IO操作，这部分可以通过ISR 标志信号，退出中断后根据信号来执行下文的模型来完成全部逻辑。

**Linux内核提供了多种底半部机制，包括软中断（softirq）、任务队列（tasklet）、工作队列（workqueue）、线程化中断（threaded IRQ）等。**

## bh 边界设置：

- `local_bh_disable()`: **禁用**当前 CPU 上的软中断和 Tasklet 处理。调用此函数后，当前 CPU 将**不会执行**任何新触发的软中断或 Tasklet（它们会被标记为挂起，但延迟执行）。
- `local_bh_enable()`: **启用**当前 CPU 上的软中断和 Tasklet 处理。如果调用此函数时检测到有挂起的软中断，它**可能**会**立即触发软中断的执行**（在当前函数返回前，或者在不久的调度点）。

- 1. `spin_lock_bh(spinlock_t *lock)`: 相当于 `spin_lock(lock)` + `local_bh_disable()`。
     1. 禁用当前 CPU 上的软中断和 Tasklet 处理 (BH)。
     2. 获取自旋锁 `lock`。如果锁已被其他 CPU 持有，则当前 CPU 在此处**忙等待**（自旋），直到锁可用。
- 2. `spin_unlock_bh(spinlock_t *lock)`: 相当于 `spin_unlock(lock)` + `local_bh_enable()`。
     1. 释放自旋锁 `lock`。
     2. 启用当前 CPU 上的软中断和 Tasklet 处理 (BH)

## 1.软中断 (Softirq)

- **设计目标：** 实现**最低延迟**的中断下文处理。对性能和实时性要求最高的场景。

SOFTIRQ ENUM

```c
//* include/linux/interrupt.h 
enum
{
	HI_SOFTIRQ=0,       //*高优先级tasklet
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,      // 块设备专用
	IRQ_POLL_SOFTIRQ,   // IRQ 轮询
	TASKLET_SOFTIRQ,    //* 常规tasklet
	SCHED_SOFTIRQ,      //* 调度器
	HRTIMER_SOFTIRQ,    /* 高精定时器，未使用 Unused,*/
	RCU_SOFTIRQ,        /*read copy update，数据同步
                        //*Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};
```
### 特性

- **可重入与并发：** **同一个**软中断类型可以在**不同的 CPU 上同时运行**其处理函数。这是软中断实现高性能的关键。例如，`NET_RX_SOFTIRQ` 可以同时在 CPU0 和 CPU1 上处理接收到的网络包。
- **执行环境**： 软中断处理函数运行在软中断上下文（Software Interrupt Context）。这个环境比硬件中断上下文（上半部）宽松：
  
  - 硬件中断是开启的（新的硬件中断可以抢占打断正在执行的软中断）。
  - 可以**嵌套**执行软中断（一个软中断处理函数可以触发另一个软中断）。
  - 但是，它仍然不是进程上下文！ 在软中断上下文中：
    
    - 不能休眠（不能调用可能阻塞的函数）： 因为内核无法在此上下文中进行进程调度。
    
    - 不能访问用户空间内存： 因为此时可能没有任何关联的用户进程。

- **触发时机：** 软中断的触发和执行发生在以下时刻：

  - **硬件中断处理程序退出时（最常见）：** 这是主要的触发点。当 CPU 从中断上半部返回时，内核**会检查是否有挂起的软中断**（通过检查一个每 CPU 位掩码 `__softirq_pending`），如果有且没有被禁用，则立即执行它们。
  - **本地 BH 开禁边界：** 当调用 `local_bh_enable()` 或 `spin_unlock_bh()` 来重新启用本 CPU 的软中断处理时，**内核会检查是否挂起软中断，并执行挂起的中断**。此后，在进程上下文的软中断一旦被用户挂起，就会执行。**在硬件中断上下文（上半部）中调用 `local_bh_disable()` 不会阻止当前 CPU 在本次中断退出时检查和执行挂起的软中断。**
  - api 原型 `void raise_softirq(unsigned int nr)` 用于用户挂起软中断

> 函数的可重入性 Reentrancy : 可以被随时打断而不丢失上下文的
>
> 满足下列条件的函数多数是不可重入的：
>
> - 函数体内使用了静态（static）的数据结构；
> - 函数体内调用了 malloc() 或者 free() 函数；
> - 函数体内调用了标准 I/O 函数;

### API

```c
//include/linux/interrupt.h
extern void open_softirq(int nr, void (*action)(struct softirq_action *));
extern void softirq_init(void);
extern void __raise_softirq_irqoff(unsigned int nr);

extern void raise_softirq_irqoff(unsigned int nr);
extern void raise_softirq(unsigned int nr);
```

1. **注册软中断处理函数：`void open_softirq(int nr, void (*action)(struct softirq_action *))`**

   - **作用：** 将指定的处理函数 `action` 关联到软中断号 `nr`。这是“申请”使用一个特定软中断类型的关键步骤。

   - ```c
     //自指向的函数指针,用于保持接口一致性
     struct softirq_action
     {
     	void	(*action)(struct softirq_action *);
     };
     
     //irq e.g.
     void my_softirq (struct softirq_action * h) {
         //* nothing about h
         return;
     }
     ```

2. **触发（挂起）软中断：`void raise_softirq(unsigned int nr)`**

3. **触发软中断（中断上下文优化版）：`void raise_softirq_irqoff(unsigned int nr)`**

   - **作用：** **标记**指定软中断号 `nr` 在**当前 CPU** 上为挂起状态。这**并不会立即执行处理函数**，而是设置当前 CPU 的 `__softirq_pending` 位掩码中的相应位。**实际的执行会延迟到前面提到的触发时机（中断退出、BH开禁、ksoftirqd）。**

### Coding 

**编写软中断处理函数：**

- 编写一个符合 `void (*action)(struct softirq_action *)` 签名的函数。
- 该函数必须满足软中断上下文的要求：
  - **不能休眠**（不能调用 `kmalloc(GFP_KERNEL)`, `mutex_lock`, `msleep` 等可能阻塞的函数）。
  - **必须是可重入的**（Reentrant）和**线程安全的**（Thread-safe）。因为它可能在多个 CPU 上同时被调用。
  - 通常使用**自旋锁** (`spinlock_t`) 或 **RCU** 来保护共享数据。避免使用可能休眠的锁。

```c
static void my_softirq_handler(struct softirq_action *a)
{
    // 1. 获取每CPU数据或使用锁保护共享数据
    // 2. 处理工作队列（例如，处理一批延迟的任务）
    // 3. 保持高效！避免阻塞操作！
}
```

**注册处理函数 ** `open_softirq`

```c
static int __init my_subsys_init(void)
{
    // ... 其他初始化 ...
    open_softirq(MY_NEW_SOFTIRQ, my_softirq_handler);
    return 0;
}
```

**触发软中断：**

* 在**中断上下文**：使用 `__raise_softirq_irqoff(MY_NEW_SOFTIRQ)` (确保在禁用中断的情况下调用)。
* 在**进程上下文**：使用 `raise_softirq(MY_NEW_SOFTIRQ)`

## 2.tasklet

* Tasklet 是 Linux 内核中一种重要的**中断下文（Bottom Half）处理机制**，**它建立在软中断之上**，为驱动程序提供了一种更简单、更安全的延迟执行方式。

* 使用`TASKLET_SOFTIRQ` 和`HI_SOFTIRQ` 两种软中断

* 不可并发 **相同 tasklet 不会在多个 CPU 上并发执行**

### struct `tasklet_struct`

```c
//* include/linux/interrupt.h
struct tasklet_struct
{
	struct tasklet_struct *next;
	unsigned long state;
	atomic_t count;
	void (*func)(unsigned long);
	unsigned long data;
};
//* unsigned long state;
enum
{
	TASKLET_STATE_SCHED,	/* Tasklet is scheduled for execution */
	TASKLET_STATE_RUN	/* Tasklet is running (SMP only) */
};

```

1. **count**：原子计数器
   - `0`：tasklet 已激活（可调度）
   - `非0`：tasklet 被禁用（不会执行）

### API

```c
// DECLARED and init 静态声明
DECLARE_TASKLET(name, func, data);       // 默认激活
DECLARE_TASKLET_DISABLED(name, func, data); // 初始禁用
//动态初始化
struct tasklet_struct my_tasklet;
tasklet_init(&my_tasklet, my_func, my_data);

//调度
// 调度普通优先级 tasklet
void tasklet_schedule(struct tasklet_struct *t);
// 调度高优先级 tasklet
void tasklet_hi_schedule(struct tasklet_struct *t);


//禁用/启用
// 禁用 tasklet（等待正在运行的完成）
void tasklet_disable(struct tasklet_struct *t);
// 禁用 tasklet（不等待）
void sklet_disable_nosync(struct tasklet_struct *t);
// 重新启用 tasklet
void tasklet_enable(struct tasklet_struct *t);

//释放资源
void tasklet_kill(struct tasklet_struct *t);

//回调函数原型

void (*func)(unsigned long);

void tasklet_handler(unsigned long data)
{
    spin_lock(&shared_lock);
    // 访问共享数据
    spin_unlock(&shared_lock);
}
```

**调度过程**：

1. 检查 tasklet 是否已被调度（`TASKLET_STATE_SCHED`）
2. 设置 `TASKLET_STATE_SCHED` 标志
3. 将 tasklet 加入当前 CPU 的 tasklet 队列
4. 触发对应的软中断（`TASKLET_SOFTIRQ` 或 `HI_SOFTIRQ`

# 工作队列  

* 工作队列是中断下文处理机制中唯一允许睡眠的机制，适用于需要长时间处理或可能阻塞的任务。

- **设计目标**：

    - 允许休眠（调用可能阻塞的函数）

    - 可被调度（遵循进程优先级）
    
    - 支持并发和重入
    
    - 支持延迟执行（定时工作)

### 关键组件

1. **工作项（Work）**：
   - 基本执行单元，包含要执行的函数
   - 结构：`struct work_struct`
   - 延迟工作项：`struct delayed_work`
2. **工作队列（Workqueue）**：
   - 工作项的容器
   - 结构：`struct workqueue_struct`
   - 工作队列分为**共享工作队列(系统自带维护)**和自定义工作队列，使用共享工作队列足以。
3. **工作者线程（Worker Thread）**：
   - 实际执行工作项的内核线程
   - 命名格式：`kworker/[u]CPU_ID:THREAD_ID`
   - `u` 前缀表示非绑定（unbound）线程

### struct

```c
//* include/linux/workqueue.h
struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
#ifdef CONFIG_LOCKDEP
	struct lockdep_map lockdep_map;
#endif
};

struct workqueue_struct {
    struct list_head list;     // 全局工作队列链表
    char name[24];             // 工作队列名称
    
    // 工作者线程管理
    struct worker *worker;     // 工作者线程数组
    int nr_workers;            // 工作者线程数量
    
    // 工作项管理
    struct list_head worklist; // 待处理工作项链表
    spinlock_t lock;           // 保护工作队列的锁
    
    //**********etc**********/
};
```

### API

```c
//**********INIT**********/
// 普通工作项
DECLARE_WORK(name, function);
// 延迟工作项
DECLARE_DELAYED_WORK(name, function);

// 普通工作项初始化
struct work_struct work;
INIT_WORK(&work, work_function);
// 延迟工作项初始化
INIT_DELAYED_WORK(&dwork, work_function);


//**********work_function**********/
typedef void (*work_func_t)(struct work_struct *work);

void mufunc(struct work_struct *work) {
    
}
//**********schedule**********/
//*在系统默认工作队列
// 立即调度工作
bool schedule_work(struct work_struct *work);
// 延迟调度工作
bool schedule_delayed_work(struct delayed_work *dwork, unsigned long delay);

// 在指定队列调度工作
bool queue_work(struct workqueue_struct *wq, struct work_struct *work);

// 在指定队列延迟调度工作
bool queue_delayed_work(struct workqueue_struct *wq, 
                        struct delayed_work *dwork, 
                        unsigned long delay);

// 尝试取消工作
bool cancel_work_sync(struct work_struct *work);
// 取消延迟工作
bool cancel_delayed_work_sync(struct delayed_work *dwork);
// 等待所有工作完成
void flush_workqueue(struct workqueue_struct *wq);
// 等待特定工作完成
void flush_work(struct work_struct *work);

//**********schedule**********/
struct workqueue_struct *alloc_workqueue(const char *fmt, 
                                       unsigned int flags,
                                       int max_active);

//**********free**********/
void destroy_workqueue(struct workqueue_struct *wq);
```

### Work Flow

1. **初始化**：定义工作项和处理函数
2. **调度**：将工作项加入工作队列
3. **排队**：工作者线程从队列获取工作项
4. **执行**：在工作线程上下文调用处理函数
5. **完成**：工作项从队列移除

**内核默认工作队列**

Linux 内核提供三个预定义工作队列：

```c
// 标准优先级工作队列
struct workqueue_struct *system_wq;

// 高优先级工作队列
struct workqueue_struct *system_highpri_wq;

// 长延迟容忍工作队列
struct workqueue_struct *system_long_wq;
```

使用系统队列的优势：

- 无需创建/销毁队列
- 自动管理工作者线程
- 适合大多数驱动需求

![image-20250804150550330](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508041505548.png)

### 工作队列传参技巧

```c
struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
#ifdef CONFIG_LOCKDEP
	struct lockdep_map lockdep_map;
#endif
};
```

首位成员是一个long_t 的data，可将其作为参数地址使用，从而完成工作队列的传参。

```c
struct args{
    int a,
    int b,
    inc c
};
irqreturn_t irq(int irq, void *args)
{
  printk("This is test_interrupt\n");
  // 提交工作项到工作队列
  work.data = & ( (struct args) {1,2,3} );
    
  ret = schedule_work(&work);
  return IRQ_RETVAL(IRQ_HANDLED);
}

void mufunc(struct work_struct *work) {
    struct args args = (*struct args) work.data;
}
```

### 并发管理工作队列CMWQ

并发管理工作队列（Concurrency Managed Workqueue，简称 CMWQ）是 Linux 内核中工作队列机制的**现代实现**，它彻底重构了传统工作队列的设计，解决了资源浪费、并发控制不足等核心问题。

CMWQ 的核心创新是引入了**共享工作池**概念：

![image-20250804153327420](https://ali-oss-yceachan.oss-cn-chengdu.aliyuncs.com/img-bed-typora/202508041533605.png)

### coding

```c
// 复杂场景：创建专用队列
static struct workqueue_struct *dev_wq;

static int dev_probe(struct device *dev)
{
    // 使用CMWQ特性的关键api : alloc_workqueue 创建工作队列
    dev_wq = alloc_workqueue("dev_wq", 
                            WQ_UNBOUND | WQ_MEM_RECLAIM,
                            4);
    
    // 提交工作项
    queue_work(dev_wq, &init_work);
}
#define alloc_workqueue(fmt, flags, max_active, args...)		\
	__alloc_workqueue_key((fmt), (flags), (max_active),		\
			      NULL, NULL, ##args)
#endif
```

```
FLAG ：
    WQ_UNBOUND		= 1 << 1, /* not bound to any cpu */
	WQ_FREEZABLE		= 1 << 2, /* freeze during suspend */
	WQ_MEM_RECLAIM		= 1 << 3, /* may be used for memory reclaim */
	WQ_HIGHPRI		= 1 << 4, /* high priority */
	WQ_CPU_INTENSIVE	= 1 << 5, /* cpu intensive workqueue */
	WQ_SYSFS		= 1 << 6, /* visible in sysfs, see wq_sysfs_register() */
```

# 中断线程化

中断线程化是指将中断处理程序的**中断下文作为内核线程运行**

**核心问题：传统中断处理（Top Half/Bottom Half）的局限性**

1. **硬中断上下文（Top Half）：**
   - 当中断发生时，CPU 会**立即暂停当前执行的任务**，跳转到与该中断号关联的中断处理函数（ISR - Interrupt Service Routine）中执行。
   - 这个执行环境被称为 **硬中断上下文** 或 **原子上下文**。
   - **关键限制：**
     - **不能休眠/阻塞：** 在硬中断上下文中，不能调用任何可能导致休眠或阻塞的函数（如 `kmalloc(GFP_KERNEL)`, `mutex_lock`, `msleep` 等）。因为这会冻结整个系统，中断是异步事件，调度器无法在中断上下文中运行。
     - **抢占被禁止：** 在执行 Top Half 期间，CPU 的本地中断通常是被禁用的（或该中断线被屏蔽），以防止嵌套中断导致栈溢出或复杂竞态。这增加了中断延迟（其他中断可能无法及时响应）。
     - **时间敏感：** Top Half 需要**尽可能快地**执行完毕，只做**绝对必要**的工作（如读取硬件状态、清除中断标志、将数据快速拷贝到内存），以便让 CPU 尽快响应其他中断或返回被中断的任务。长时间占用会显著降低系统响应性和实时性。
2. **软中断/工作队列/Tasklet（Bottom Half）：**
   - 为了解决 Top Half 不能做耗时操作的问题，Linux 引入了 Bottom Half 机制。
   - 常见形式：软中断（`softirq`）、任务队列（`tasklet`）、工作队列（`workqueue`）。
   - **工作原理：** Top Half 将**耗时的、可以延迟处理**的工作“调度”到一个 Bottom Half 机制中。这些 Bottom Half 会在**稍后某个更安全的时间点（通常是退出 Top Half 后不久，或在进程上下文中）** 由内核执行。
   - **局限性：**
     - **软中断/Tasklet：** 虽然比 Top Half 宽松些（允许小范围抢占），但它们**仍然运行在“软中断上下文”** 中，本质上还是**中断上下文**的延伸。它们**仍然不能休眠或阻塞**，且执行时间过长仍会影响系统实时性。
     - **工作队列：** 运行在**真正的进程上下文**中，可以休眠、阻塞、使用调度策略。这是解决耗时操作的经典方案。
     - **复杂性：** **开发者需要手动拆分中断处理流程：哪些放 Top Half，哪些放 Bottom Half（如工作队列）。这增加了编程复杂性，也引入了数据同步（锁）的开销。**

**中断线程化（Interrupt Threading）的引入**

为了克服传统 Bottom Half（尤其是软中断/tasklet）的限制，并提供**更好的实时性（RT-Preempt 补丁的核心目标之一）** 和 **更简单的编程模型**，内核引入了 **中断线程化** 的概念。`request_threaded_irq` 函数就是实现这一机制的关键 API。

## **API `request_threaded_irq` **

```c
request_threaded_irq(unsigned int irq, irq_handler_t handler,
		     irq_handler_t thread_fn,
		     unsigned long flags, const char *name, void *dev);
```

- **`irq`：** 申请的中断号。
- **`handler`：** **“硬中断”处理函数**（也叫 Primary Handler）。它在**硬中断上下文**中运行，具有和传统 Top Half 相同的限制（不能休眠、需快速完成）。它的**返回值**至关重要。
- **`thread_fn`：** **中断线程处理函数**。如果 `handler` 指示需要，这个函数将在**一个专用的内核线程上下文**中运行。
- **`irqflags`：** 中断标志位（如 `IRQF_SHARED`, `IRQF_ONESHOT`）。`IRQF_ONESHOT` 对于线程化中断尤其重要，它确保在线程处理完成前，该中断线不会被再次触发（防止重入）。
- **`name`：** 设备标识名（出现在 `/proc/interrupts`）。
- **`dev`：** 传递给处理函数的设备标识符（主要用于共享中断）

## **工作流程**

> （核心在于 `handler` 的返回值）

1. **硬件中断发生：** CPU 跳转到中断向量，最终路由到为该中断线注册的“硬中断”处理函数 `handler`。
2. **`handler` 执行（在硬中断上下文）：**
   - 执行**最紧急、必须立即处理**的任务（如确认中断、读取关键寄存器、清除硬件中断标志）。
   - **关键决策点：`handler` 返回以下值之一：**
     - **`IRQ_NONE`:** 该中断不是本设备产生的（通常用于共享中断线）。内核继续尝试其他处理程序。
     - **`IRQ_HANDLED`:** 中断已被 `handler` **完全处理**，不需要唤醒线程 `thread_fn`。这是**不启用线程化功能**的用法（等价于 `request_irq`）。
     - **`IRQ_WAKE_THREAD`:** `handler` 完成了必要的快速操作，但还有**耗时工作**需要处理。内核会**唤醒**与该中断关联的**专用内核线程**来执行 `thread_fn`。
3. **`thread_fn` 执行（在线程上下文）：**
   - 当 `handler` 返回 `IRQ_WAKE_THREAD` 后，内核调度器会在**合适的时机**调度一个**专用的内核线程**（通常每个线程化中断或每个 CPU 有一个线程池）。
   - 在这个**内核线程上下文**中执行 `thread_fn` 函数。
   - **关键优势：**
     - **可以休眠/阻塞：** 可以调用任何内核函数（`kmalloc(GFP_KERNEL)`, `mutex_lock`, `msleep` 等）。
     - **支持调度：** 可以设置线程的优先级（如 `SCHED_FIFO`, `SCHED_RR`），这对于**实时系统至关重要**。高优先级的中断线程可以抢占低优先级的普通线程或低优先级的中断线程。
     - **允许长时间运行：** 处理耗时任务不会直接阻塞其他中断或显著增加中断延迟。
   - `thread_fn` 的返回值：`IRQ_NONE` 或 `IRQ_HANDLED`，含义与 `handler` 的类似。